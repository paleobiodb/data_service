-- 
-- This file was generated by scripts/timescale_tables.pl. You should not edit it directly, but
-- rather edit TimescaleTables.pl and re-run the script.
-- 

delimiter //

CREATE OR REPLACE PROCEDURE complete_bound_updates ( )
	BEGIN

	SET @row_count = 1;
	SET @age_iterations = 0;
	
	# For all updated records where the precision fields have not been
	# set, set them to the position of the last nonzero digit after the
	# decimal place.
	
	UPDATE timescale_bounds
	SET age_prec = coalesce(age_prec, length(regexp_substr(age, '(?<=[.])\\d*?(?=0*$)'))),
	    age_error_prec = coalesce(age_error_prec, 
				length(regexp_substr(age_error, '(?<=[.])\\d*?(?=0*$)'))),
	    fraction_prec = coalesce(fraction_prec, length(regexp_substr(fraction, '(?<=[.])\\d*?(?=0*$)')))
	WHERE is_updated and (age_prec is null or age_error_prec is null or fraction_prec is null);
	
	# Now update the ages and flags on all bounds that are marked as is_updated.  If
	# this results in any updated records, repeat the process until no
	# records change. We put a limit of 20 on the number of iterations.
	
	WHILE @row_count > 0 AND @age_iterations < 20 DO
	    
	    UPDATE timescale_bounds as tsb
		left join timescale_bounds as `base` on base.bound_no = tsb.base_no
		left join timescale_bounds as `range` on range.bound_no = tsb.range_no
		left join timescale_bounds as `csource` on csource.bound_no = tsb.color_no
	    SET tsb.is_updated = 1,
		tsb.is_spike = case tsb.bound_type
			when 'same' then base.is_spike
			else tsb.is_spike
			end,
		tsb.age = case tsb.bound_type
			when 'same' then base.age
			when 'fraction' then if(tsb.age_updated, tsb.age,
						round(base.age - tsb.fraction * ( base.age - range.age ),
						      tsb.age_prec))
					           # greatest(least(coalesce(base.age_prec, 0), 
						   #                coalesce(range.age_prec, 0)),
						   # 	    if(base.age > 600, 0, 1)))
			else tsb.age
			end,
		tsb.age_prec = case tsb.bound_type
			when 'same' then base.age_prec
			# when 'fraction' then least(coalesce(base.age_prec, 0),
			# 			   coalesce(range.age_prec, 0))
			else tsb.age_prec
			end,
		tsb.age_error = case tsb.bound_type
			when 'same' then base.age_error
			# when 'fraction' then coalesce(greatest(base.age_error, range.age_error),
			# 			     base.age_error, range.age_error)
			else tsb.age_error
			end,
		tsb.age_error_prec = case tsb.bound_type
			when 'same' then base.age_error_prec
			# when 'fraction' then least(coalesce(base.age_error_prec, 0),
			# 			  coalesce(range.age_error_prec, 0))
			else tsb.age_error_prec
			end,
		tsb.is_spike = case tsb.bound_type
			when 'spike' then 1
			when 'same' then base.is_spike
			else 0
			end,
		tsb.color = coalesce(csource.color, tsb.color)
	    WHERE base.is_updated or range.is_updated or tsb.is_updated;
	    
	    SET @row_count = ROW_COUNT();
	    SET @age_iterations = @age_iterations + 1;
	    
	    # SET @debug = concat(@debug, @cnt, ' : ');
	    
	    # Now make sure that every fractional bound that explicitly had its age set has the
	    # proper fraction set. We do this step last so that if the base and/or range bound are
	    # also being updated then they will attain their final values before we do this
	    # computation. As part of this step, we clear the 'age_updated' flag.
	    
	    UPDATE timescale_bounds as tsb
		left join timescale_bounds as `base` on base.bound_no = tsb.base_no
		left join timescale_bounds as `range` on range.bound_no = tsb.range_no
	    SET tsb.fraction = if(base.age is not null and range.age is not null and tsb.age is not null and
					base.age <> range.age,
				  round((base.age - tsb.age) / (base.age - range.age), 4),
				  null),
		tsb.age_updated = 0
	    WHERE tsb.age_updated;
	    
	END WHILE;
	
	END //

CREATE OR REPLACE PROCEDURE update_timescale_ages ( t int unsigned )
	BEGIN
	
	UPDATE timescales as `ts` join
	    (SELECT age, age_prec, timescale_no FROM timescale_bounds
	     WHERE timescale_no = t
	     ORDER BY age LIMIT 1) as `min` using (timescale_no)
	SET ts.min_age = min.age
	WHERE timescale_no = t;
	
	UPDATE timescales as `ts` join
	    (SELECT age, age_prec, timescale_no FROM timescale_bounds
	     WHERE timescale_no = t
	     ORDER BY age desc LIMIT 1) as `max` using (timescale_no)
	SET ts.max_age = max.age
	WHERE timescale_no = t;
	
	END //

CREATE OR REPLACE PROCEDURE check_updated_timescales ( )
	BEGIN
	
	UPDATE timescale_bounds as `tsb` join timescales as `ts` using (timescale_no)
	SET ts.is_updated = 1 WHERE tsb.is_updated;
	
	UPDATE timescale_bounds as `tsb` join timescales as `ts` using (timescale_no)
		left join timescale_bounds as `upper` on upper.bound_no = tsb.top_no
		left join timescale_bounds as `base` on base.bound_no = tsb.base_no
		left join timescale_bounds as `range` on range.bound_no = tsb.range_no
	SET tsb.has_error =
		if((tsb.age is null) or
		   (upper.age is not null and tsb.age <= upper.age) or
		   (upper.timescale_no <> tsb.timescale_no) or
		   (tsb.bound_type = 'fraction' and (range.bound_no is null or
						     tsb.fraction is null or 
						     not tsb.fraction between 0 and 1)) or
		   (tsb.bound_type in ('base', 'fraction') and base.bound_no is null),
		   1, 0)
	WHERE ts.is_updated;
	
	UPDATE timescale_bounds as `tsb` join
	    (SELECT timescale_no, b.interval_name, count(*) as `c`
	     FROM timescale_bounds as `b` join timescales as `ts` using (timescale_no)
	     WHERE b.interval_name <> '' and ts.is_updated
	     GROUP BY timescale_no, interval_name HAVING `c`>1) as `duplicate_bounds` using (timescale_no, interval_name) 
	SET tsb.has_error = 1;
	
	UPDATE timescales as `ts` join
	    (SELECT timescale_no, min(b.age) as `min`, max(b.age) as `max`, max(b.has_error) as `has_error`
	     FROM timescale_bounds as `b` join timescales as `t` using (timescale_no)
	     WHERE t.is_updated GROUP BY timescale_no) as `all_bounds` using (timescale_no)
	SET ts.min_age = all_bounds.min,
	    ts.max_age = all_bounds.max,
	    ts.has_error = all_bounds.has_error,
	    ts.bounds_updated = now();
	
	END //

CREATE OR REPLACE PROCEDURE link_timescale_bounds ( t int unsigned )
    	BEGIN
	
    	SET @last_bound := 0, @save_bound := 0;
	
    	UPDATE timescale_bounds
    	SET top_no = last_value(@save_bound := @last_bound, @last_bound := bound_no, @save_bound)
    	WHERE timescale_no = t ORDER BY age;
	
    	END //

CREATE OR REPLACE PROCEDURE unmark_updated_bounds ( )
    	BEGIN
	
    	UPDATE timescale_bounds SET is_updated = 0;
	UPDATE timescales SET is_updated = 0;
	
    	END //

delimiter ;

use pbdbTEST;

delimiter //

CREATE OR REPLACE PROCEDURE complete_bound_updates ( )
	BEGIN

	SET @row_count = 1;
	SET @age_iterations = 0;
	
	# For all updated records where the precision fields have not been
	# set, set them to the position of the last nonzero digit after the
	# decimal place.
	
	UPDATE timescale_bounds
	SET age_prec = coalesce(age_prec, length(regexp_substr(age, '(?<=[.])\\d*?(?=0*$)'))),
	    age_error_prec = coalesce(age_error_prec, 
				length(regexp_substr(age_error, '(?<=[.])\\d*?(?=0*$)'))),
	    fraction_prec = coalesce(fraction_prec, length(regexp_substr(fraction, '(?<=[.])\\d*?(?=0*$)')))
	WHERE is_updated and (age_prec is null or age_error_prec is null or fraction_prec is null);
	
	# Now update the ages and flags on all bounds that are marked as is_updated.  If
	# this results in any updated records, repeat the process until no
	# records change. We put a limit of 20 on the number of iterations.
	
	WHILE @row_count > 0 AND @age_iterations < 20 DO
	    
	    UPDATE timescale_bounds as tsb
		left join timescale_bounds as `base` on base.bound_no = tsb.base_no
		left join timescale_bounds as `range` on range.bound_no = tsb.range_no
		left join timescale_bounds as `csource` on csource.bound_no = tsb.color_no
	    SET tsb.is_updated = 1,
		tsb.is_spike = case tsb.bound_type
			when 'same' then base.is_spike
			else tsb.is_spike
			end,
		tsb.age = case tsb.bound_type
			when 'same' then base.age
			when 'fraction' then if(tsb.age_updated, tsb.age,
						round(base.age - tsb.fraction * ( base.age - range.age ),
						      tsb.age_prec))
					           # greatest(least(coalesce(base.age_prec, 0), 
						   #                coalesce(range.age_prec, 0)),
						   # 	    if(base.age > 600, 0, 1)))
			else tsb.age
			end,
		tsb.age_prec = case tsb.bound_type
			when 'same' then base.age_prec
			# when 'fraction' then least(coalesce(base.age_prec, 0),
			# 			   coalesce(range.age_prec, 0))
			else tsb.age_prec
			end,
		tsb.age_error = case tsb.bound_type
			when 'same' then base.age_error
			# when 'fraction' then coalesce(greatest(base.age_error, range.age_error),
			# 			     base.age_error, range.age_error)
			else tsb.age_error
			end,
		tsb.age_error_prec = case tsb.bound_type
			when 'same' then base.age_error_prec
			# when 'fraction' then least(coalesce(base.age_error_prec, 0),
			# 			  coalesce(range.age_error_prec, 0))
			else tsb.age_error_prec
			end,
		tsb.is_spike = case tsb.bound_type
			when 'spike' then 1
			when 'same' then base.is_spike
			else 0
			end,
		tsb.color = coalesce(csource.color, tsb.color)
	    WHERE base.is_updated or range.is_updated or tsb.is_updated;
	    
	    SET @row_count = ROW_COUNT();
	    SET @age_iterations = @age_iterations + 1;
	    
	    # SET @debug = concat(@debug, @cnt, ' : ');
	    
	    # Now make sure that every fractional bound that explicitly had its age set has the
	    # proper fraction set. We do this step last so that if the base and/or range bound are
	    # also being updated then they will attain their final values before we do this
	    # computation. As part of this step, we clear the 'age_updated' flag.
	    
	    UPDATE timescale_bounds as tsb
		left join timescale_bounds as `base` on base.bound_no = tsb.base_no
		left join timescale_bounds as `range` on range.bound_no = tsb.range_no
	    SET tsb.fraction = if(base.age is not null and range.age is not null and tsb.age is not null and
					base.age <> range.age,
				  round((base.age - tsb.age) / (base.age - range.age), 4),
				  null),
		tsb.age_updated = 0
	    WHERE tsb.age_updated;
	    
	END WHILE;
	
	END //

CREATE OR REPLACE PROCEDURE update_timescale_ages ( t int unsigned )
	BEGIN
	
	UPDATE timescales as `ts` join
	    (SELECT age, age_prec, timescale_no FROM timescale_bounds
	     WHERE timescale_no = t
	     ORDER BY age LIMIT 1) as `min` using (timescale_no)
	SET ts.min_age = min.age
	WHERE timescale_no = t;
	
	UPDATE timescales as `ts` join
	    (SELECT age, age_prec, timescale_no FROM timescale_bounds
	     WHERE timescale_no = t
	     ORDER BY age desc LIMIT 1) as `max` using (timescale_no)
	SET ts.max_age = max.age
	WHERE timescale_no = t;
	
	END //

CREATE OR REPLACE PROCEDURE check_updated_timescales ( )
	BEGIN
	
	UPDATE timescale_bounds as `tsb` join timescales as `ts` using (timescale_no)
	SET ts.is_updated = 1 WHERE tsb.is_updated;
	
	UPDATE timescale_bounds as `tsb` join timescales as `ts` using (timescale_no)
		left join timescale_bounds as `upper` on upper.bound_no = tsb.top_no
		left join timescale_bounds as `base` on base.bound_no = tsb.base_no
		left join timescale_bounds as `range` on range.bound_no = tsb.range_no
	SET tsb.has_error =
		if((tsb.age is null) or
		   (upper.age is not null and tsb.age <= upper.age) or
		   (upper.timescale_no <> tsb.timescale_no) or
		   (tsb.bound_type = 'fraction' and (range.bound_no is null or
						     tsb.fraction is null or 
						     not tsb.fraction between 0 and 1)) or
		   (tsb.bound_type in ('base', 'fraction') and base.bound_no is null),
		   1, 0)
	WHERE ts.is_updated;
	
	UPDATE timescale_bounds as `tsb` join
	    (SELECT timescale_no, b.interval_name, count(*) as `c`
	     FROM timescale_bounds as `b` join timescales as `ts` using (timescale_no)
	     WHERE b.interval_name <> '' and ts.is_updated
	     GROUP BY timescale_no, interval_name HAVING `c`>1) as `duplicate_bounds` using (timescale_no, interval_name) 
	SET tsb.has_error = 1;
	
	UPDATE timescales as `ts` join
	    (SELECT timescale_no, min(b.age) as `min`, max(b.age) as `max`, max(b.has_error) as `has_error`
	     FROM timescale_bounds as `b` join timescales as `t` using (timescale_no)
	     WHERE t.is_updated GROUP BY timescale_no) as `all_bounds` using (timescale_no)
	SET ts.min_age = all_bounds.min,
	    ts.max_age = all_bounds.max,
	    ts.has_error = all_bounds.has_error,
	    ts.bounds_updated = now();
	
	END //

CREATE OR REPLACE PROCEDURE link_timescale_bounds ( t int unsigned )
    	BEGIN
	
    	SET @last_bound := 0, @save_bound := 0;
	
    	UPDATE timescale_bounds
    	SET top_no = last_value(@save_bound := @last_bound, @last_bound := bound_no, @save_bound)
    	WHERE timescale_no = t ORDER BY age;
	
    	END //

CREATE OR REPLACE PROCEDURE unmark_updated_bounds ( )
    	BEGIN
	
    	UPDATE timescale_bounds SET is_updated = 0;
	UPDATE timescales SET is_updated = 0;
	
    	END //

delimiter ;

