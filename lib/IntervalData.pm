#
# IntervalQuery
# 
# A class that returns information from the PaleoDB database about time intervals.
# This is a subclass of PBDataQuery.
# 
# Author: Michael McClennen

package IntervalData;

use strict;
use base 'Web::DataService::Request';

use Web::DataService qw( :validators );

use Carp qw(carp croak);

use CommonData qw(generateReference);
use IntervalTables qw($INTERVAL_DATA $INTERVAL_MAP $SCALE_DATA $SCALE_MAP $SCALE_LEVEL_DATA);

our (@REQUIRES_CLASS) = qw(CommonData);


# initialize ( )
# 
# This routine is called automatically by the data service to initialize this
# class.

sub initialize {

    my ($class, $ds) = @_;
    
    # Start by defining an output map to specify which output blocks will be
    # used to display the results generated by this class.
    
    $ds->define_output_map( '1.1:intervals:basic_map' =>
	{ value => 'basic', maps_to => '1.1:intervals:basic', fixed => 1 });
	#{ value => 'ref', maps_to => '1.1:common:ref' },
	#    "The primary reference for the interval, as formatted text.");
    
    # Then define the output blocks that haven't already been defined
    # elsewhere.
    
    $ds->define_block( '1.1:intervals:basic' =>
	{ select => [ qw(i.interval_no i.interval_name i.abbrev sm.scale_no sm.level
			 sm.parent_no sm.color i.early_age i.late_age i.reference_no) ] },
	{ output => 'interval_no', com_name => 'oid' },
	    "A positive integer that uniquely identifies this interval",
	{ output => 'record_type', com_name => 'typ', com_value => 'int', value => 'interval' },
	    "The type of this object: 'int' for an interval",
	{ output => 'scale_no', com_name => 'sca' },
	    "The time scale in which this interval lies.  An interval may be reported more than",
	    "once, as a member of different time scales",
	{ output => 'level', com_name => 'lvl' },
	    "The level within the time scale to which this interval belongs",
	{ output => 'interval_name', com_name => 'nam' },
	    "The name of this interval",
	{ output => 'abbrev', com_name => 'abr' },
	    "The standard abbreviation for the interval name, if any",
	{ output => 'parent_no', com_name => 'pid' },
	    "The identifier of the parent interval",
	{ output => 'color', com_name => 'col' },
	    "The standard color for displaying this interval",
	{ output => 'late_age', com_name => 'lag' },
	    "The late age boundary of this interval (in Ma)",
	{ output => 'early_age', com_name => 'eag' },
	    "The early age boundary of this interval (in Ma)",
	{ set => 'reference_no', append => 1 },
	{ output => 'reference_no', com_name => 'rid', text_join => ', ' },
	    "The identifier(s) of the references from which this data was entered");
    
    # Then define some rulesets to describe the parameters accepted by the
    # operations defined here.

    $ds->define_ruleset('1.1:interval_selector' => 
	{ param => 'scale_id', valid => [POS_VALUE, ENUM_VALUE('all')], 
	  list => ',', alias => 'scale',
	  error => "the value of {param} should be a list of positive integers or 'all'" },
	    "Return intervals from the specified time scale(s).",
	    "The value of this parameter should be a list of positive integers or 'all'",
	{ param => 'min_ma', valid => DECI_VALUE(0) },
	    "Return only intervals that are at least this old",
	{ param => 'max_ma', valid => DECI_VALUE(0) },
	    "Return only intervals that are at most this old",
	{ optional => 'order', valid => ENUM_VALUE('older', 'younger'), default => 'younger' },
	    "Return the intervals in order starting as specified.  Possible values include ",
	    "C<older>, C<younger>.  Defaults to C<younger>.");
    
    $ds->define_ruleset('1.1:interval_specifier' =>
	{ param => 'id', valid => POS_VALUE },
	    "Return the interval corresponding to the specified identifier. (REQUIRED)");

    $ds->define_ruleset('1.1:intervals:list' => 
	{ allow => '1.1:interval_selector' },
	{ allow => '1.1:common_params' },
	"^You can also use any of the L<common parameters|/data1.1/common> with this request");

    $ds->define_ruleset('1.1:intervals:single' => 
	{ allow => '1.1:interval_specifier' },
	{ allow => '1.1:common_params' },
	"^You can also use any of the L<common parameters|/data1.1/common> with this request");

}


# get ( )
# 
# Query for all relevant information about the interval specified by the
# 'id' parameter.  Returns true if the query succeeded, false otherwise.

sub get {

    my ($self) = @_;
    
    # Get a database handle by which we can make queries.
    
    my $dbh = $self->get_dbh;
    
    # Make sure we have a valid id number.
    
    my $id = $self->{params}{id};
    
    die "Bad identifier '$id'" unless defined $id and $id =~ /^\d+$/;
    
    # Determine which fields and tables are needed to display the requested
    # information.
    
    my $fields = $self->select_string({ mt => 'i' });
    
    # Determine the necessary joins.
    
    my ($join_list) = $self->generateJoinList('i', $self->{select_tables});
    
    # Generate the main query.
    
    $self->{main_sql} = "
	SELECT $fields
	FROM $INTERVAL_DATA as i LEFT JOIN $SCALE_MAP as sm using (interval_no)
		$join_list
        WHERE i.interval_no = $id
	GROUP BY i.interval_no";
    
    print STDERR $self->{main_sql} . "\n\n" if $self->debug;
    
    $self->{main_record} = $dbh->selectrow_hashref($self->{main_sql});
    
    # If we were asked to get the count, then do so
    
    $self->sql_count_rows;
    
    return 1;
}


# list ( )
# 
# Query the database for basic info about all specified intervals.
# 
# Returns true if the fetch succeeded, false if an error occurred.

sub list {

    my ($self) = @_;
    
    # Get a database handle by which we can make queries.
    
    my $dbh = $self->get_dbh;
    
    # If we were asked for a hierarchy, indicate that we will need to process
    # the result set before sending it.
    
    $self->{process_resultset} = \&generateHierarchy if 
	defined $self->{op} && $self->{op} eq 'hierarchy';
    
    # Construct a list of filter expressions that must be added to the query
    # in order to select the proper result set.
    
    my @filters;
    
    if ( defined $self->{params}{scale} and $self->{params}{scale} eq 'all' )
    {
	push @filters, "sm.level is not null";
    }
    
    elsif ( ref $self->{params}{scale_id} eq 'ARRAY' )
    {
	my $filter_string = join(',', @{$self->{params}{scale_id}});
	
	if ( $filter_string !~ /all/ )
	{
	    push @filters, "sm.scale_no in ($filter_string)";
	}
    }
    
    if ( exists $self->{params}{min_ma} )
    {
	my $min = $self->{params}{min_ma};
	push @filters, "i.late_age >= $min";
    }
    
    if ( exists $self->{params}{max_ma} )
    {
	my $max = $self->{params}{max_ma};
	push @filters, "i.early_age <= $max";
    }
    
    push @filters, "1=1" unless @filters;
    
    # Get the results in the specified order
    
    my $order_expr = defined $self->{params}{order} && $self->{params}{order} eq 'younger' ?
	"ORDER BY sm.scale_no, sm.level, i.late_age" :
	    "ORDER BY sm.scale_no, sm.level, i.early_age desc";
    
    # Determine which fields and tables are needed to display the requested
    # information.
    
    my $fields = $self->select_string({ mt => 'i' });
    
    # Determine the necessary joins.
    
    my ($join_list) = $self->generateJoinList('i', $self->{select_tables});
    
    # If a query limit has been specified, modify the query accordingly.
    
    my $limit = $self->sql_limit_clause(1);
    
    # If we were asked to count rows, modify the query accordingly
    
    my $calc = $self->sql_count_clause;
    
    # Generate the main query.
    
    my $filter_list = join(' and ', @filters);
    
    $self->{main_sql} = "
	SELECT $calc $fields
	FROM $INTERVAL_DATA as i LEFT JOIN $SCALE_MAP as sm using (interval_no)
		$join_list
	WHERE $filter_list
	$order_expr
	$limit";
    
    print STDERR $self->{main_sql} . "\n\n" if $self->debug;
    
    # Then prepare and execute the main query.
    
    $self->{main_sth} = $dbh->prepare($self->{main_sql});
    $self->{main_sth}->execute();
    
    # If we were asked to get the count, then do so
    
    $self->sql_count_rows;
        
    return 1;
}


# generateJoinList ( tables )
# 
# Generate the actual join string indicated by the table hash.

sub generateJoinList {

    my ($self, $mt, $tables) = @_;
    
    my $join_list = '';
    
    # Return an empty string unless we actually have some joins to make
    
    return $join_list unless ref $tables eq 'HASH' and %$tables;
    
    # Create the necessary join expressions.
    
    $join_list .= "LEFT JOIN refs as r on r.reference_no = $mt.reference_no\n" 
	if $tables->{r};
    
    return $join_list;
}


# generateScaleEntry ( )
# 
# Return a list of (scale_no, level).

sub generateScaleEntry {
    
    my ($self, $rowref) = @_;
    
    return [$rowref->{scale_no}, $rowref->{level}];
}


# generateHierarchy ( rows )
# 
# Arrange the rows into a hierarchy.  This is only called on requests
# which use the 'hierarchy' route.

sub generateHierarchy {

    my ($self, $rowref) = @_;
    
    return $rowref unless $self->{output_format} eq 'json';
    
    my @toplevel = ();
    my %row = ();
    
    foreach my $r ( @$rowref )
    {
	$r->{hier_child} ||= [];
	$row{$r->{interval_no}} = $r;
	
	if ( $r->{level} == 1 )
	{
	    push @toplevel, $r;
	}
	
	else
	{
	    my $parent_no = $r->{parent_no};
	    $row{$parent_no}{hier_child} ||= [];
	    push @{$row{$parent_no}{hier_child}}, $r;
	}
    }
    
    return \@toplevel;
}


# initOutput ( )
# 
# This routine is used in case we are generating hierarchical output, setting
# up the necessary data structures to do so.  If we are just generating a
# list, this is irrelevant but harmless.

sub initOutput {

    my ($self) = @_;
    
    $self->{tree_stack} = [];
    $self->{comma_stack} = [];
    
    return;
}

1;
