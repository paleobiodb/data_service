#
# EditTransaction::Conditions - a role that provides routines for handling error, caution, and
# warning conditions.
#


package EditTransaction::Conditions;

use strict;

use EditTransaction qw(%CONDITION_BY_CLASS);
use Carp qw(croak);

use Moo::Role;

no warnings 'uninitialized';


# Error, caution, and warning conditions
# --------------------------------------

# Error and warning conditions are indicated by codes, all composed of upper case word symbols. Those
# that start with 'E_' represent errors, those that start with 'C_' represent cautions, and those
# that start with 'W_' represent warnings. In general, errors cause the operation to be aborted
# while warnings do not. Cautions cause the operation to be aborted unless specifically allowed.
# 
# Codes that start with 'C_' indicate cautions that may be allowed, so that the operation proceeds
# despite them. A canonical example is 'C_CREATE', which is returned if records are to be
# created. If the data service operation method knows that records are to be created, it can
# explicitly allow 'CREATE', which will allow the records to be created. Alternatively, it can
# return 'C_CREATE' as an error code to the client-side application, which can ask the user if
# they really want to create new records. If they answer affirmatively, the operation can be
# re-tried with 'CREATE' specifically allowed. The same can be done with other cautions.
# 
# Codes that start with 'E_' indicate conditions that prevent the operation from proceeding. For
# example, 'E_PERM' indicates that the user does not have permission to operate on the specified
# record or table. 'E_NOT_FOUND' indicates that a record to be updated is not in the
# database. Unlike cautions, these conditions cannot be specifically allowed. However, the special
# allowance 'PROCEED' specifies that whatever parts of the operation are able to succeed
# should be carried out, even if some record operations fail. The special allowance 'NOT_FOUND'
# indicates that E_NOT_FOUND should be demoted to a warning, and that particular record skipped,
# but other errors will still block the operation from proceeding.
# 
# Codes that start with 'W_' indicate warnings that should be passed back to the client but do not
# prevent the operation from proceeding.
# 
# Codes that start with 'D_' and 'F_' indicate conditions that would otherwise have been cautions
# or errors, under the 'PROCEED', 'NOT_FOUND', or 'NOT_PERMITTED' allowances. These are treated as
# warnings.
# 
# Allowed conditions must be specified for each EditTransaction object when it is created.

our ($CONDITION_CODE_STRICT) = qr{ ^ [CEW]_ [A-Z0-9_-]+ $ }x;
our ($CONDITION_CODE_LOOSE) =  qr{ ^ [CEFW]_ [A-Z0-9_-]+ $ }x;
our ($CONDITION_CODE_START) =  qr{ ^ [CEFW]_ }x;
our ($CONDITION_LINE_IMPORT) = qr{ ^ ([CEFW]_[A-Z0-9_-]+) (?: \s* [(] .*? [)] )? (?: \s* : \s* )? (.*) }x;

# register_conditions ( condition ... )
#
# Register the names and templates of conditions which may be generated by transactions in a
# particular subclass. This is designed to be called at startup from modules which subclass this
# one.

sub register_conditions {

    my $class = shift;
    
    croak "you must call this as a class method" unless $class->isa('EditTransaction') && ! ref $class;
    
    # Process the arguments in pairs.
    
    while ( @_ )
    {
	my $code = shift;
	
	croak "you must specify an even number of arguments" unless @_;
	
	my $template = shift;
	
	# Make sure the code follows the proper pattern and the template is defined. It may be
	# the empty string, but it must be given.
	
	croak "bad condition code '$code'" unless $code =~ $CONDITION_CODE_STRICT;
	croak "bad condition template '$template'" unless defined $template;
	
	$CONDITION_BY_CLASS{$class}{$code} = $template;
    }
};


# add_condition ( [action], code, param... )
# 
# Add a condition (error, caution, or warning) that pertains to the either the entire
# transaction or to a single action. The condition is specified by a code, optionally
# followed by one or more parameters which will be used later to generate an error or
# warning message. Conditions that pertain to an action may be demoted to warnings if
# any of the allowances PROCEED, NOT_FOUND, or NOT_PERMITTED was specified.
# 
# If the first parameter is a reference to an action, then the condition will be attached
# to that action. If it is the undefined value or the string 'main', then the condition
# will apply to the transaction as a whole. Otherwise, the condition will be attached to
# the current action if there is one or the transaction as a whole otherwise.
#
# This method either adds the condition, or else throws an exception.

sub add_condition {
    
    my ($edt, @params) = @_;
    
    # Start by determining the action (if any) to which this condition should be attached.
    
    my ($action, $code);

    # If the first parameter is a Perl reference, it must be a reference to an
    # action. This method should only be called in this way from within this class and its
    # subclasses. Outside code should always refer to actions using string references.
    
    if ( ref $params[0] )
    {
	$action = shift @params;
	
	unless ( $action->isa('EditTransaction::Action') )
	{
	    my $ref_string = ref $action;
	    croak "'$ref_string' is not an action reference";
	}
    }
    
    # If the first parameter is either 'main' or the undefined value, then the condition
    # will be attached to the transaction as a whole.
    
    elsif ( ! defined $params[0] || $params[0] eq 'main' )
    {
	shift @params;
    }
    
    # If the first parameter starts with '&', look it up as an action reference. Calls of
    # this kind will always come from outside code.
    
    elsif ( $params[0] =~ /^&./ )
    {
	unless ( $action = $edt->{action_ref}{$params[0]} )
	{
	    croak "no matching action found for '$params[0]'";
	}
	
	shift @params;
    }
    
    # Otherwise, default to the current action. Depending on when this method is called,
    # it may be empty, in which case the condition will be attached to the transaction as
    # a whole. If the first parameter is 'latest', remove it.
    
    else
    {
	$action = $edt->{current_action};

	if ( $action && ! ( ref $action && $action->isa('EditTransaction::Action') ) )
	{
	    die "current_action is not a valid action reference";
	}
	
	shift @params if $params[0] eq 'latest';
    }
    
    # There must be at least one remaining parameter, and it must match the syntax of a
    # condition code. If it starts with F, change it back to E. If it does not have the
    # form of a condition code, throw an exception. Any subsequent parameters will be kept
    # and used to generate the condition message.
    
    if ( $params[0] && $params[0] =~ $CONDITION_CODE_LOOSE )
    {
	$code = shift @params;

	if ( $code =~ /^F/ )
	{
	    substr($code, 0, 1) = 'E';
	}
    }
    
    else
    {
	croak "'$params[0]' is not a valid selector or condition code";
    }
    
    # If this condition belongs to an action, add it to that action. Adjust the condition counts
    # for the transaction, but only if the action is not marked as skipped. If the action already
    # has this exact condition, return without doing anything.
    
    if ( $action )
    {
	# When an error condition is attached to an action and this transaction allows
	# PROCEED, the error is demoted to a warning. If this transaction allows NOT_FOUND,
	# then an E_NOT_FOUND error is demoted to a warning but others are not.
	
	if ( $action && $code =~ /^E/ && ref $edt->{allows} eq 'HASH' )
	{
	    if ( $edt->{allows}{PROCEED} ||
		 $edt->{allows}{NOT_FOUND} && $code eq 'E_NOT_FOUND' ||
		 $edt->{allows}{NOT_PERMITTED} && $code eq 'E_PERM' )
	    {
		substr($code, 0, 1) = 'F';
	    }
	}

	# Try to add this condition to the action. If add_condition fails, that means the
	# condition duplicates one that is already attached to the action. If it succeeds,
	# then update the transaction condition counts unless this is a skipped action.
	
	if ( $action->add_condition($code, @params) && $action->status ne 'skipped' )
	{
	    # This code in this block includes guard statements that reset any invalid
	    # counts to zero before incrementing them. If the guard statement triggers, it
	    # means that any prior count has already been lost. So we start again from zero,
	    # rather than losing the count anyway or throwing an exception that will probably
	    # not be caught.

	    $edt->{condition_code}{$code}++;
	    
	    # If the code starts with E or C then it represents an error or caution.
	    
	    if ( $code =~ /^[EC]/ )
	    {
		$edt->{error_count}++;
	    }
	    
	    # If the code starts with F, then it represents a demoted error. It counts as a
	    # warning for the transaction as a whole, but as an error for the action.
	    
	    elsif ( $code =~ /^F/ )
	    {
		$edt->{demoted_count}++;
	    }
	    
	    # Otherwise, it represents a warning.
	    
	    else
	    {
		$edt->{warning_count}++;
	    }
	    
	    # Return true to indicate that the condition was attached.
	    
	    return 1;
	}
    }
    
    # Otherwise, the condition is to be attached to the transaction as a whole unless it
    # duplicates one that is already there. If the transaction already has this exact
    # condition, return without doing anything. Use the same kind of guard statements as
    # above, and also on the condition list.
    
    elsif ( ! $edt->_has_main_condition($code, @params) )
    {
	$edt->{conditions} = [ ] unless ref $edt->{conditions} eq 'ARRAY';
	push $edt->{conditions}->@*, [undef, $code, @params];
	
	$edt->{condition_code}{$code}++;
	
	# If the code starts with [EC], it represents an error or caution.
	
	if ( $code =~ /^[EC]/ )
	{
	    $edt->{error_count}++;
	}
	
	# Otherwise, it represents a warning.
	
	else
	{
	    $edt->{warning_count}++;
	}

	# Return 1 to indicate that the condition was attached.

	return 1;
    }
    
    # If we get here, return false. Either the condition was a duplicate, or the action
    # was skipped or aborted and thus is not counted.
    
    return;
}


# has_condition ( [selector], code, [arg1, arg2, arg3] )
#
# Return true if this transaction contains a condition with the specified code. If 1-3 extra
# arguments are also given, return true only if each argument value matches the
# corresponding condition parameter. The code may be specified either as a string or a regex.
# 
# If the first argument is 'main', the condition lists for the transaction as a whole are
# searched. If it is an action reference, the condition lists for that action are searched. If it
# is 'all', then all condition lists are searched. This is the default.

sub has_condition {
    
    my ($edt, $code, @v) = @_;
    
    my $selector = 'all';
    
    # If the first argument is a valid selector, remap the arguments.
    
    if ( $code =~ /^main|^all|^latest|^&./ )
    {
	($edt, $selector, $code, @v) = @_;
    }
    
    # Make sure that we were given either a regex or a string starting with [CDEFW] as the
    # code to look for.
    
    unless ( $code && (ref $code && reftype $code eq 'REGEXP' || $code =~ $CONDITION_CODE_LOOSE ) )
    {
	croak $code ? "'$code' is not a valid selector or condition code" :
	    "you must specify a condition code";
    }
    
    # If the selector is either 'main' or 'all', check the main condition list.  Return true if we
    # find an entry that has the proper code and also matches any extra values that were given.
    
    if ( $selector eq 'main' || $selector eq 'all' )
    {
	return 1 if $edt->_has_main_condition($code, @v);
	
	# If the selector is 'all', return true if any of the actions has a matching
	# condition. Return false otherwise.
	
	if ( $selector eq 'all' && ref $edt->{action_list} eq 'ARRAY' )
	{
	    foreach my $action ( $edt->{action_list}->@* )
	    {
		return 1 if $action->has_condition($code, @v);
	    }
	}

	return 0;
    }
    
    # If the selector is 'latest', check the current action.
    
    elsif ( $selector eq 'latest' )
    {
	if ( $edt->{current_action} )
	{
	    return $edt->{current_action}->has_condition($code, @v);
	}
    }
    
    # If the selector is an action reference, check that action.
    
    elsif ( $selector =~ /^&./ )
    {
	if ( my $action = $edt->{action_ref}{$selector} )
	{
	    return $action->has_condition($code, @v);
	}

	else
	{
	    croak "no matching action found for '$selector'";
	}
    }

    else
    {
	croak "'$selector' is not a valid selector";
    }
    
    # If we didn't find a matching condition, return false.
    
    return 0;
}


sub _has_main_condition {

    my ($edt, $code, @v) = @_;

    my $is_regexp = ref $code && reftype $code eq 'REGEXP';
    
    if ( ref $edt->{conditions} eq 'ARRAY' )
    {
	foreach my $i ( 0 .. $edt->{conditions}->$#* )
	{
	    my $c = $edt->{conditions}[$i];
	    
	    if ( ref $c eq 'ARRAY' &&
		( $code eq $c->[1] || $is_regexp && $c->[1] =~ $code) &&
		( @v == 0 || ( ! defined $v[0] || $v[0] eq $c->[2] ) &&
			     ( ! defined $v[1] || $v[1] eq $c->[3] ) &&
			     ( ! defined $v[2] || $v[2] eq $c->[4] ) ) )
	    {
		return $i + 1;
	    }
	}
    }
}


# # add_condition_simple ( code, param... )
# #
# # Attach the specified condition to the current action, or to the transaction as a whole
# # if the current action is undefined. This method is designed to be called only from this
# # class or a subclass. It does not do any argument checking, so it is risky to call it
# # from interface code. However, it is more robust. Unlike add_condition, it should never
# # throw an exception as long as the first parameter is a string.

# sub add_condition_simple {
    
#     my ($edt, $code, @params) = @_;

#     my $action;
    
#     # If current_action is defined and is a reference to an action, attach the condition
#     # to it. If the condition is an error and the transaction allows PROCEED or NOT_FOUND,
#     # demote the error to a warning.
    
#     if ( $edt->{current_action} && ref $edt->{current_action} &&
# 	 $edt->{current_action}->isa('EditTransaction::Action') )
#     {
# 	$action = $edt->{current_action};
	
# 	if ( $code =~ /^E/ && ref $edt->{allows} eq 'HASH' &&
# 	     ( $edt->{allows}{PROCEED} || $edt->{allows}{NOT_FOUND} && $code eq 'E_NOT_FOUND' ) )
# 	{
# 	    substr($code,0,1) =~ 'F';
# 	}
#     }
    
#     # Create a condition object using these parameters, and attach it to the action or to
#     # the transaction as a whole.
    
#     my $condition = EditTransaction::Condition->new($action, $code, @params);
    
#     $edt->_attach_condition($action, $condition, $code);
# }


# conditions ( [selector], [type] )
# 
# In list context, return a list of stringified error and/or warning conditions recorded
# for this transaction. In scalar context, return how many there are. The selector and
# type can be given in either order. The selector can be any of the following, defaulting
# to 'all':
# 
#     main		Return conditions that are attached to the transaction as a whole.
#     latest		Return conditions that are attached to the latest action.
#     :...              Return conditions that are attached to the referenced action.
#     all		Return all conditions.
# 
# The type can be any of the following, also defaulting to 'all':
# 
#     errors		Return only error conditions.
#     fatal		With selector 'all', return error conditions that were not demoted to warnings.
#     nonfatal		With selector 'all', return warning conditions and demoted errors.
#     warnings		Return only warning conditions.
#     all		Return all conditions.
#
# The types 'fatal' and 'nonfatal' are the same as 'errors' and 'warnings' respectively when used
# with any selector other than 'all'. 

my %TYPE_RE = ( errors => qr/^[EFC]/,
		fatal => qr/^[EC]/,
		nonfatal => qr/^[FW]/,
		warnings => qr/^W/,
		all => qr/^[EFCW]/ );

my $csel_pattern = qr{ ^ (?: main$|latest$|all$|:. ) }xs;
my $ctyp_pattern = qr{ ^ (?: errors$|fatal$|nonfatal$|warnings$ ) }xs;

sub conditions {
    
    my ($edt, @params) = @_;
    
    local ($_);
    
    # First extract the selector and type from the parameters. They can occur in either
    # order. Both are optional, defaulting to 'all'.
    
    my $selector = 'all';
    my $type = 'all';
    
    if ( $params[0] )
    {
	if ( $params[0] =~ $csel_pattern )
	{
	    $selector = $params[0];
	}

	elsif ( $params[0] =~ $ctyp_pattern )
	{
	    $type = $params[0];
	}

	elsif ( $params[0] ne 'all' )
	{
	    croak "'$params[0]' is not a valid selector or condition type";
	}
    }

    if ( $params[1] )
    {
	if ( $params[1] =~ $csel_pattern && $selector eq 'all' )
	{
	    $selector = $params[1];
	}

	elsif ( $params[1] =~ $ctyp_pattern && $type eq 'all' )
	{
	    $type = $params[1];
	}

	elsif ( $params[1] ne 'all' )
	{
	    croak "'$params[1]' is not a valid selector or condition type";
	}
    }
    
    # Get the proper regexp to pull out the desired conditions.
    
    my $filter = $TYPE_RE{$type} || $TYPE_RE{all};
    
    # If the selector is 'main', grep through the main conditions list.
    
    if ( $selector eq 'main' )
    {
    	if ( wantarray )
    	{
    	    return map { $edt->condition_string($_->@*) }
		grep { ref $_ eq 'ARRAY' && $_->[1] =~ $filter }
		$edt->_main_conditions;
    	}
	
    	else
    	{
    	    return grep { ref $_ eq 'ARRAY' && $_->[1] =~ $filter } $edt->_main_conditions;
    	}
    }
    
    # my @keys = $TYPE_KEYS{$type}->@*;
    
    # # For 'main', we return either or both of the 'errors' and 'warnings' lists from $edt.
    
    # if ( $selector eq 'main' )
    # {
    # 	if ( wantarray )
    # 	{
    # 	    return map( $edt->condition_string($_), map( $edt->{$_} && $edt->{$_}->@*, @keys ));
    # 	}
	
    # 	else
    # 	{
    # 	    return sum( map( scalar($edt->{$_} && $edt->{$_}->@*), @keys ));
    # 	}
    # }
    
    # For 'latest', we return either or both of the 'errors' and 'warning' lists from
    # the current action. For an action reference, we use the corresponding action.
    
    elsif ( $selector =~ /^latest|^&./ )
    {
	my $action;
	
	if ( $selector eq 'latest' )
	{
	    $action = $edt->{current_action} || return;
	}
	
	else
	{
	    $action = $edt->{action_ref}{$selector} || croak "no matching action found for '$selector'";
	}
	
	if ( wantarray )
	{
	    return map { $edt->condition_string($_->@*) }
		grep { ref $_ eq 'ARRAY' && $_->[1] =~ $filter }
		$action->conditions;
	}
	
	else
	{
	    return grep { ref $_ eq 'ARRAY' && $_->[1] =~ $filter } $action->conditions;
	}
    }
    
    # For 'all' in list context, we grep both the main conditions list and the one for
    # every action.
    
    elsif ( wantarray )
    {
	return map { $edt->condition_string($_->@*) }
	    grep { ref $_ eq 'ARRAY' && $_->[1] =~ $filter }
	    $edt->_main_conditions,
	    map { $_->status ne 'skipped' ? $_->conditions : () } $edt->_action_list;
    }
    
	# if ( wantarray && ( $type eq 'all' || $type eq 'nonfatal' ) )
	# {
	#     my $filter = '!EC' if $type eq 'nonfatal';
	    
	#     return map { $edt->condition_string($_, $filter) }
	# 	$edt->{errors} ? $edt->{errors}->@* : (),
	# 	$edt->{warnings} ? $edt->{warnings}->@* : (),
	# 	map { ( $_->{errors} ? $_->{errors}->@* : () ,
	# 		$_->{warnings} ? $_->{warnings}->@* : () ) }
	# 	grep { $_->{status} ne 'skipped' } $edt->{action_list}->@*;
	# }
	
	# # With any other type, there is just one key to check.
	
	# elsif ( wantarray )
	# {
	#     my $key = $keys[0];
	#     my $filter = 'EC' if $type eq 'fatal';
	    
	#     return map { $edt->condition_string($_, $filter) }
	# 	$edt->{$key} ? $edt->{$key}->@* : (),
	# 	map { $_->{$key} ? $_->{$key}->@* : () }
	# 	grep { $_->{status} ne 'skipped' } $edt->{action_list}->@*;
	# }
	
    # For 'all' in scalar context, return the count(s) that correspond to $type.
    
    elsif ( $type eq 'errors' )
    {
	return $edt->{error_count} + $edt->{demoted_count};
    }
    
    elsif ( $type eq 'warnings' )
    {
	return $edt->{warning_count};
    }
    
    elsif ( $type eq 'fatal' )
    {
	return $edt->{error_count};
    }
    
    elsif ( $type eq 'nonfatal' )
    {
	return $edt->{warning_count} + $edt->{demoted_count};
    }
    
    else
    {
	return $edt->{error_count} + $edt->{demoted_count} + $edt->{warning_count};
    }
}


sub _main_conditions {

    return ref $_[0]{conditions} eq 'ARRAY' ? $_[0]{conditions}->@* : ();
}


# condition_string ( condition )
#
# Return a stringified version of the specified condition tuple (action, code, parameters...).

sub condition_string {

    my ($edt, $label, $code, @params) = @_;
    
    # If no code was given, return undefined.
    
    return unless $code;
    
    # If this condition is associated with an action, include the action's label in
    # parentheses.
    
    my $labelstr = defined $label && $label ne '' ? " ($label)" : "";
    
    if ( my $msg = $edt->condition_message($code, @params) )
    {
	return "${code}${labelstr}: ${msg}";
    }
    
    else
    {
	return "${code}${labelstr}";
    }
}


sub condition_nolabel {

    my ($edt, $label, $code, @params) = @_;
    
    return unless $code;
    
    if ( my $msg = $edt->condition_message($code, @params) )
    {
	return "${code}: ${msg}";
    }
    
    else
    {
	return $code;
    }
}


# has_errors ( )
#
# If this EditTransaction has accumulated any fatal errors, return the count. Otherwise, return
# false.

sub has_errors {

    return $_[0]{error_count} || 0;
}


# errors ( [selector] )
# 
# This is provided for backward compatibility. When called with no arguments in scalar
# context, it efficiently returns the error condition count. Otherwise, the argument is
# passed to the 'conditions' method.

sub errors {
    
    my ($edt, $selector) = @_;

    if ( wantarray || $selector )
    {
	return $edt->conditions($selector || 'all', 'errors');
    }

    else
    {
	return $edt->{error_count} + $edt->{demoted_count};
    }
}


# warnings ( [selector] )
# 
# Like 'errors', this method is provided for backward compatibility. When called with no
# arguments in scalar context, it efficiently returns the warning condition
# count. Otherwise, the argument is passed to the 'conditions' method. 

sub warnings {

    my ($edt, $selector) = @_;
    
    if ( wantarray || $selector )
    {
	return $edt->conditions($selector || 'all', 'warnings');
    }
    
    else
    {
	return $edt->{warning_count};
    }
}


# error_strings ( ) and warning_strings ( )
#
# These are deprecated aliases for 'errors' and 'warnings'.

sub error_strings {

    goto &errors;
}


sub warning_strings {

    goto &warnings;
}


# fatals ( [selector] )
#
# When called with no arguments in scalar context, this method efficiently returns the fatal
# condition count. Otherwise, the argument is passed to the 'conditions' method.

sub fatals {

    my ($edt, $selector) = @_;

    if ( wantarray || $selector )
    {
	return $edt->conditions($selector || 'all', 'fatal');
    }

    else
    {
	return $edt->{error_count};
    }
}


# nonfatals ( [selector] )
#
# When called with no arguments in scalar context, this method efficiently returns the nonfatal
# condition count. Otherwise, the argument is passed to the 'conditions' method.

sub nonfatals {

    my ($edt, $selector) = @_;

    if ( wantarray || $selector )
    {
	return $edt->conditions($selector || 'all', 'nonfatal');
    }

    else
    {
	return $edt->{warning_count} + $edt->{demoted_count};
    }
}


# has_condition_code ( code... )
#
# Return true if any of the specified codes have been attached to the current transaction.

sub has_condition_code {
    
    my $edt = shift;
    
    local ($_);
    
    # Return true if any of the following codes are found.
    
    return any { 1; $edt->{condition_code}{$_}; } @_;
}


# condition_message ( code, [parameters...] )
# 
# This routine generates an error message from a condition code and optinal associated
# parameters.

sub condition_message {
    
    my ($edt, $code, @params) = @_;
    
    # If the code was altered because of the PROCEED allowance, change it back
    # so we can look up the proper template.
    
    my $lookup = $code;
    substr($lookup,0,1) =~ tr/F/E/;
    
    # Look up the template according to the specified code and first parameter.  This may
    # return one or more templates.
    
    my @templates = $edt->get_condition_template($lookup, $params[0]);
    
    # Remove any undefined values from the end of the parameter list, so that the proper template
    # will be selected for the parameters given.
    
    pop @params while @params > 0 && ! defined $params[-1];
    
    # Run down the list until we find a template for which all of the required parameters have values.

  TEMPLATE:
    foreach my $tpl ( @templates )
    {
	if ( defined $tpl && $tpl ne '' )
	{
	    my @required = $tpl =~ /[&](\d)/g;
	    
	    foreach my $n ( @required )
	    {
		next TEMPLATE unless defined $params[$n-1] && $params[$n-1] ne '';
	    }
	    
	    $tpl =~ s/ [&](\d) / &_squash_param($params[$1-1]) /xseg;
	    return $tpl;
	}
    }
    
    # If none of the templates are fulfilled, concatenate the parameters with a space
    # between each one.
    
    return join(' ', @params);
}


# _squash_param ( param )
#
# Return a value suitable for inclusion into a message template. If the parameter value is longer
# than 40 characters, it is truncated and ellipses are appended. If the value is not defined, then
# 'UNKNOWN' is returned.

sub _squash_param {

    if ( defined $_[0] && length($_[0]) > 80 )
    {
	return substr($_[0],0,80) . '...';
    }
    
    else
    {
	return $_[0] // 'UNKNOWN';
    }
}


# get_condition_template ( code, selector, param_count )
#
# Given a code, a table, and an optional selector string, return a message template.  This method
# is designed to be overridden by subclasses, but the override methods must call
# SUPER::get_condition_template if they cannot find a template for their particular class that
# corresponds to the information they are given.

sub get_condition_template {

    my ($edt, $code, $selector) = @_;
    
    my $template = $CONDITION_BY_CLASS{ref $edt}{$code} //
	           $CONDITION_BY_CLASS{EditTransaction}{$code};
    
    if ( ref $template eq 'HASH' && $template->{$selector} )
    {
	$template = $template->{$selector};
    }
    
    elsif ( ref $template eq 'HASH' && $template->{default} )
    {
	$template = $template->{default};
    }
    
    # If we have reached a string value, return it. If it is a non-empty list, return
    # the list contents.
    
    if ( $template && ref $template eq 'ARRAY' && $template->@* )
    {
	return $template->@*;
    }
    
    elsif ( defined $template && ! ref $template )
    {
	return $template;
    }
    
    # Otherwise, return the UNKNOWN template.
    
    else
    {
	return $selector ? $CONDITION_BY_CLASS{EditTransaction}{'UNKNOWN'} . " for '$selector'"
	    : $CONDITION_BY_CLASS{EditTransaction}{'UNKNOWN'} . " for 'code'";
    }
}


# import_conditions ( action, external_condition... )
# 
# Import information generated elsewhere that represents error or warning conditions, and add one
# or more condition records to the specified action.

sub import_conditions {

    my ($edt, $action, @arguments) = @_;
    
    # Add every condition specified in the argument list to the current transaction and the
    # current action. Each element might be a list of lists, or a single list, or a list of strings,
    # or a single string.
    
    my @conditions;
    
    foreach my $arg ( @arguments )
    {
	if ( ref $arg eq 'ARRAY' && $arg->@* )
	{
	    if ( $arg->[0] && $arg->[0] =~ $CONDITION_CODE_START )
	    {
		if ( $arg->[1] && $arg->[1] =~ $CONDITION_CODE_START )
		{
		    push @conditions, $arg->@*;
		}
		
		else
		{
		    push @conditions, $arg;
		}
	    }
	    
	    elsif ( ref $arg->[0] eq 'ARRAY' )
	    {
		push @conditions, $arg->@*;
	    }
	    
	    else
	    {
		push @conditions, ['E_BAD_CONDITION', "Unrecognized data format for import", ref $arg];
		last;
	    }
	}
	
	elsif ( ref $arg )
	{
	    push @conditions, ['E_BAD_CONDITION', "Unrecognized data format for import", ref $arg];
	    last;
	}
	
	elsif ( $arg && $arg =~ $CONDITION_CODE_START )
	{
	    push @conditions, $arg;
	}
	
	else
	{
	    push @conditions, ['E_BAD_CONDITION', "Unrecognized data format for import", $arg];
	    last;
	}
    }
    
    foreach my $c ( @conditions )
    {
	if ( ref $c eq 'ARRAY' )
	{
	    my $code = shift $c->@*;
	    
	    if ( $code && $code =~ $CONDITION_CODE_LOOSE )
	    {
		$edt->_import_condition($action, $code, $c->@*);
	    }
	    
	    else
	    {
		$edt->add_condition($action, 'E_BAD_CONDITION', "Invalid condition code", $code);
	    }
	}
	
	elsif ( $c =~ $CONDITION_LINE_IMPORT )
	{
	    $edt->_import_condition($action, $1, $2);
	}
	
	elsif ( $c )
	{
	    $c =~ qr{ ^ (\w+) }xs;
	    $edt->add_condition($action, 'E_BAD_CONDITION', "Invalid condition code", $1);
	}
    }
}


sub _import_condition {

    my ($edt, $action, $code, $message) = @_;
    
    # Return the code to its canonical version.
    
    substr($code, 0, 1) =~ tr/DF/CE/;
    
    # If we have a template corresponding to that code, add the condition as is.
    
    if ( $edt->get_condition_template($code) )
    {
	$edt->add_condition($action, $code, $message);
    }
    
    # Otherwise, change any warning condition to 'W_IMPORTED' and all other conditions to
    # 'E_IMPORTED'. A condition that does not have either an 'E' or a 'W' prefix might be
    # an error, so we assume that it is.
    
    else
    {
	my $newcode = $code =~ /^W/ ? 'W_IMPORTED' : 'E_IMPORTED';
	$edt->add_condition($action, $newcode, "$code: $message");
    }
}


1;
