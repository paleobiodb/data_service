# 
# EditTransaction::Execution
# 
# This role provides a framework for executing database actions. Execution for
# most actions is handled by the database interface module.
# 


package EditTransaction::Execution;

use strict;

use TableDefs qw(%TABLE);
use Switch::Plain;
use Carp qw(carp croak);
use Fcntl qw(:flock SEEK_END);
use Encode;

use Role::Tiny;

no warnings 'uninitialized';


# execute_action_list ( )
# 
# Execute any pending actions. This is called either by 'execute' or by 'start_execution'. If
# $complete is true, then these are all of the remaining actions for this EditTransaction.

sub execute_action_list {

    my ($edt, $arg) = @_;
    
    local ($_);
    
    # Iterate through the action list, starting after the last completed action.
    
    my $start_index = $edt->{completed_count};
    my $end_index = $edt->{action_list}->$#*;
    
  ACTION:
    foreach my $i ( $start_index .. $end_index )
    {
	my $action = $edt->{action_list}[$i];
	
	# If this particular action has been executed, aborted, or skipped, then pass over it.
	
	next ACTION if $action->has_completed;
	
	# If any errors have accumulated on this transaction, mark all remaining
	# actions as 'unexecuted'. This includes any errors that may have been
	# generated by the previous action.
	
	unless ( $edt->can_proceed )
	{
	    $edt->{skip_count}++;
	    $action->{status} = 'unexecuted';
	    next ACTION;
	}
	
	# If this particular action has any errors, then skip it. We need to do this check
	# separately, because if PROCEED has been set for this transaction then any errors that
	# were generated during validation of this action will have been demoted.  But in that
	# case, $action->errors will still return true, and this action should not be executed.
	
	if ( $action->has_errors )
	{
	    $edt->{fail_count}++;
	    $action->{status} = 'failed';
	    next ACTION;
	}
	
	# Set the current action and the current external action, then execute the appropriate
	# handler for this action's operation. If the current action is a child action, keep track
	# of its parent.
	
	$edt->{current_action} = $action;
	
	sswitch ( $action->operation )
	{
	    case 'insert': {
		$edt->pre_execution_check($action) && $edt->execute_insert($action);
	    }
	    
	    case 'update': {
		$edt->pre_execution_check($action) && $edt->execute_update($action);
	    }
	    
	    case 'replace': {
		$edt->pre_execution_check($action) && $edt->execute_replace($action);
	    }
	    
	    case 'delete': {
		$edt->pre_execution_check($action) && $edt->execute_delete($action);
	    }
	    
	    case 'delete_cleanup' : {
		$edt->pre_execution_check($action) && $edt->execute_delete_cleanup($action);
	    }
	    
	    case 'other': {
		$edt->pre_execution_check($action) && $edt->execute_other($action);
	    }
	    
	  default: {
		$edt->add_condition($action, 'E_EXECUTE', "An error occurred while routing this action");
		$edt->error_line("execute_action_list: bad operation '$_'");
	    }
	}
    }
    
    # # If this is the completion of the EditTransaction and no fatal errors have occurred, execute
    # # any pending operations.
    
    # if ( $arg eq 'FINAL' && $edt->can_proceed )
    # {
    # 	$edt->_cleanup_pending_actions;
    # }
    
    # Update the count of completed actions. If this routine is called again, it will skip
    # over everything on the list as of now.
    
    $edt->{completed_count} = scalar($edt->{action_list}->@*);
    
    # If the current action is a child action, reset the current action to its parent. This means
    # that subsequent client calls such as 'add_condition' will affect the parent and not its
    # children.
    
    if ( my $parent_action = $edt->{current_action} && $edt->{current_action}->parent )
    {
	$edt->{current_action} = $parent_action;
    }
}


# _cleanup_pending_actions ( )
#
# If there are any pending deletes, execute them now.

sub _cleanup_pending_actions {

    my ($edt) = @_;

    if ( $edt->{pending_deletes} && $edt->{pending_deletes}->@* )
    {
	my $delete_action = pop $edt->{pending_deletes}->@*;
	$delete_action->_coalesce($edt->{pending_deletes});
	
	delete $edt->{pending_deletes};
	$edt->{current_action} = $delete_action;
	
	$edt->_execute_delete($delete_action);
    }
}


# pre_execution_check ( action, operation )
#
# This method is called immediately before each action is executed. It starts by doing any
# necessary substitutions of action references for key values. If authorization and/or validation
# are still pending, those steps are carried out now. If any errors result, the action is marked
# as 'failed'. Returns true if the action can be executed, false otherwise.

sub pre_execution_check {
    
    my ($edt, $action, $operation, $table_specifier) = @_;
    
    # If the authorization step has not been completed, do so now.
    
    my $permission = $action->permission;
    
    if ( ! $permission || $permission eq 'PENDING' )
    {
	$permission = $edt->authorize_action($action, $operation, $table_specifier, 'FINAL');
    }
    
    # If we don't have a valid permission by this point (including 'none'), something went wrong.
    
    unless ( $permission && $permission ne 'PENDING' )
    {
	$edt->add_condition($action, 'E_EXECUTE', "An error occurred while checking authorization");
	$edt->error_line("Permission for '$operation' was '$permission' at execution time");
    }
    
    # If the validation steps have not yet been completed, do so now. If the validation status is
    # 'PENDING', start by calling 'validate_action'. This only occurs if a previous call to
    # 'validate_action' put off the validation until now by calling 'validate_later'.
    
    if ( $action->validation_status eq 'PENDING' )
    {
	$edt->validate_action($action, $operation, $table_specifier);
    }
    
    # If the operation is 'insert', 'update', or 'replace', we need to call
    # 'validate_against_schema' if it has not already been called. If the validation is not
    # complete afterward, something went wrong.
    
    if ( $operation =~ /insert|update|replace/ )
    {
	# We have to check the status again, because 'validate_action' might have set it to
	# 'COMPLETE'.
	
	if ( $action->validation_status eq 'PENDING' )
	{
	    $edt->validate_against_schema($action, $operation, $table_specifier, 'FINAL');
	}
	
	unless ( $action->validation_status eq 'COMPLETE' )
	{
	    my $vs = $action->validation_status;
	    $edt->add_condition($action, 'E_EXECUTE', "An error occurred while checking validation");
	    $edt->error_line("Validation for '$operation' was '$vs' at execution time");
	}
    }
    
    # If any prechecks have been defined for this action, do them now.
    
    $edt->_do_all_prechecks($action, $operation, $table_specifier);
    
    # If the action can now proceed, return true. This implies that no error conditions were added
    # during execution of this subroutine. 

    if ( $action->can_proceed )
    {
	return 1;
    }
    
    # Otherwise, return false. If the action has errors and the status isn't already 'failed',
    # then set it and increment the fail count.
    
    elsif ( $action->has_errors && $action->status ne 'failed' )
    {
	$edt->{fail_count}++;
	$action->set_status('failed');
    }
    
    return 0;
}


# _do_all_prechecks ( action, operation, table )
#
# Carry out any prechecks that have been defined for this action.

sub _do_all_prechecks {

    my ($edt, $action, $operation, $table_specifier) = @_;
    
    # Get the lists of column names and values from the action. They are returned as references,
    # so this routine can modify the contents.
    
    my $cols = $action->column_list;
    my $vals = $action->value_list;
    
    # Iterate through all of the prechecks, recording which columns are affected.
    
    my (%fkey_check);
    
    foreach my $check ( $action->all_prechecks )
    {
	# A 'foreign_key' precheck checks the column value against a foreign table.
	
	if ( $check->[0] eq 'foreign_key' )
	{
	    my $colname = $check->[1];
	    
	    $fkey_check{$colname} = $check;
	}
    }
    
    # Then iterate through all of the columns, checking values and modifying them if necessary.
    
    foreach my $i ( 0 .. $#$cols )
    {
	# If this column needs a 'foreign_key' check, do that.
	
	if ( $fkey_check{$cols->[$i]} )
	{
	    my $colname   = $cols->[$i];
	    my $fieldname = $fkey_check{$colname}[2];
	    my $ftable =    $fkey_check{$colname}[3];
	    my $fcolname =  $fkey_check{$colname}[4] || get_table_property($ftable, 'PRIMARY_KEY');
	    my $checkval =  $vals->[$i];
	    
	    # If the column value is still a reference, substitute it with the keyval of the
	    # corresponding action. If an error occurs, set the value to undef instead.
	    
	    if ( $checkval =~ /^&./ )
	    {
		if ( my $ref_action = $edt->{action_ref}{$checkval} )
		{
		    my $refkey = $ref_action->keyval;
		    
		    # If there are too few or too many keys, set the column value to undefined and
		    # add an appropriate error condition.

		    if ( ! $refkey )
		    {
			$checkval = undef;
			$edt->add_condition($action, 'E_BAD_REFERENCE', '_unresolved_',
					    $fieldname, $checkval);
		    }
		    
		    elsif ( ref $refkey eq 'ARRAY' )
		    {
			$checkval = undef;
			$edt->add_condition($action, 'E_BAD_REFERENCE', '_multiple_',
					    $fieldname, $checkval);
		    }

		    else
		    {
			$checkval = $refkey;
		    }
		}
		
		else
		{
		    $checkval = undef;
		    $edt->add_condition($action, 'E_BAD_REFERENCE', '_unresolved_',
					$fieldname, $checkval);
		}
	    }
	    
	    # If we have a nonempty value and it exists in the foreign table, store it back into
	    # the value list.
	    
	    if ( defined $checkval && $edt->check_key($ftable, $fcolname, $checkval) )
	    {
		$vals->[$i] = $checkval;
	    }
	    
	    # Otherwise, set the value to something that will cause an SQL error if executed. This
	    # is a failsafe, because the execution should be aborted before that point.

	    else
	    {
		$vals->[$i] = '_INVALID_';
	    }
	}
    }
}


# # _substitute_labels ( action )
# #
# # Substitute the values in the columns marked for substitution with the key value associated with
# # the corresponding labels.

# sub _substitute_labels {
    
#     my ($edt, $action) = @_;
    
#     my $needs_substitution = $action->label_sub;
#     my $columns = $action->column_list;
#     my $values = $action->value_list;
    
#     # Step through the columns, checking to see which ones have labels that must be substituted.
    
#     foreach my $index ( 0..$#$columns )
#     {
# 	my $col_name = $columns->[$index];
# 	my $raw_value = $values->[$index];
	
# 	next unless $col_name && $needs_substitution->{$col_name};
# 	next unless $raw_value && $raw_value =~ /^&./;
	
# 	# $$$ need to check that the referenced action has the proper table.
	
# 	if ( $edt->{label_ref}{$raw_value} )
# 	{
# 	    my $key_value = $edt->{label_ref}{$raw_value}->keyval;

# 	    if ( ref $key_value eq 'ARRAY' )
# 	    {
# 		$edt->add_condition($action, 'E_BAD_REFERENCE', '_multiple_', $col_name, $raw_value);
# 	    }

# 	    elsif ( $key_value )
# 	    {
# 		$values->[$index] = $key_value;
# 	    }

# 	    else
# 	    {
# 		$edt->add_condition($action, 'E_BAD_REFERENCE', '_unresolved_', $col_name, $raw_value);
# 	    }
# 	}

# 	else
# 	{
# 	    $edt->add_condition($action, 'E_BAD_REFERENCE', $col_name, $raw_value);
# 	}
#     }
# }


# # set_keyexpr ( action )
# # 
# # Generate a key expression for the specified action, that will select the particular record being
# # acted on. If the action has no key value (i.e. is an 'insert' operation) or if no key column is
# # known for this table then return '0'. The reason for returning this value is that it can be
# # substituted into an SQL 'WHERE' clause and will be syntactically correct but always false.

# sub set_keyexpr {
    
#     my ($edt, $action) = @_;
    
#     my $keycol = $action->keycol;
#     my $keyval = $action->keyval;
#     my $keyexpr;

#     # If we have already computed a key expression, even if it is 0, return it.
    
#     if ( defined($keyexpr = $action->keyexpr) )
#     {
# 	return $keyexpr;
#     }
    
#     # Otherwise, if there is no key column then the key expression is just 0.
    
#     elsif ( ! $keycol )
#     {
# 	$action->set_keyexpr('0');
# 	return '0';
#     }

#     # If we get here, then we need to compute the key expression.
    
#     if ( $action->is_multiple )
#     {
# 	my $dbh = $edt->dbh;
# 	my @keys = map { $dbh->quote($_) } $action->all_keys;
	
# 	unless ( @keys )
# 	{
# 	    $action->set_keyexpr('0');
# 	    return '0';
# 	}
	
# 	$keyexpr = "$keycol in (" . join(',', @keys) . ")";
#     }
    
#     elsif ( defined $keyval && $keyval ne '' && $keyval ne '0' )
#     {
# 	if ( $keyval =~ /^@(.*)/ )
# 	{
# 	    my $label = $1;
	    
# 	    if ( $keyval = $edt->{label_keys}{$label} )
# 	    {
# 		$action->set_keyval($keyval);
# 	    }
	    
# 	    else
# 	    {
# 		$edt->add_condition($action, 'E_LABEL_NOT_FOUND', $keycol, $label);
# 	    }
# 	}

# 	elsif ( $keyval =~ /^[0-9+]$/ )
# 	{
# 	    # do nothing
# 	}

# 	elsif ( $keyval =~ $IDRE{LOOSE} )
# 	{
# 	    my $type = $1;
# 	    my $num = $2;
	    
# 	    my $exttype = $COMMON_FIELD_IDTYPE{$keycol};
	    
# 	    if ( $exttype )
# 	    {
# 		if ( $type eq $exttype )
# 		{
# 		    $keyval = $num;
# 		}

# 		else
# 		{
# 		    $edt->add_condition($action, 'E_EXTID', $keycol, "external identifier must be of type '$exttype', was '$type'");
# 		}
# 	    }
	    
# 	    else
# 	    {
# 		$edt->add_condition($action, 'E_EXTID', $keycol, "no external identifier is defined for this primary key");
# 	    }
# 	}
	
# 	$keyexpr = "$keycol=" . $edt->dbh->quote($keyval);
#     }
    
#     if ( $keyexpr )
#     {
# 	$action->set_keyexpr($keyexpr);
# 	return $keyexpr;
#     }

#     else
#     {
# 	$action->set_keyexpr('0');
# 	return '0';
#     }
# }


# # get_keyexpr ( action )
# #
# # If the action already has a key expression, return it. Otherwise, generate one and return it.

# sub get_keyexpr {
    
#     my ($edt, $action) = @_;

#     if ( my $keyexpr = $action->keyexpr )
#     {
# 	return $keyexpr;
#     }

#     else
#     {
# 	return $edt->set_keyexpr($action);
#     }
# }


# # aux_keyexpr ( table, keycol, keyval )
# #
# # Generate a key expression that will select the indicated record from the table.

# sub aux_keyexpr {
    
#     my ($edt, $action, $table_key, $keycol, $keyval, $record_col) = @_;

#     if ( $action )
#     {
# 	$table_key ||= $action->table;
# 	$keycol ||= $action->keycol;
# 	$keyval ||= $action->keyvalues;
# 	$record_col ||= $action->keyrec;
#     }
    
#     # If we are given an empty key value, or '0', then we cannot generate a key expression. Add an
#     # E_REQUIRED error condition to the action, and return.
    
#     if ( ! defined $keyval || $keyval eq '0' || $keyval eq '' )
#     {
# 	$edt->add_condition($action, 'E_REQUIRED', $record_col) if $action;
# 	return 0;
#     }

#     # If we are given a positive integer value, we can use that directly.
    
#     elsif ( $keyval =~ /^[0-9]+$/ && $keyval > 0 )
#     {
# 	return "$keycol='$keyval'";
#     }

#     # If we are given a label, we need to look it up and find the key value to which the label
#     # refers. We also need to check to make sure that this label refers to a key value in the
#     # proper table.
    
#     elsif ( $keyval =~ /^&(.+)/ )
#     {
# 	# my $label = $1;
# 	# my $lookup_val = $edt->{label_keys}{$label};

# 	# $$$ switch to action references
	
# 	# if ( $lookup_val && $edt->{label_found}{$label} eq $table_key )
# 	# {
# 	#     return "$keycol='$lookup_val'";
# 	# }
	
# 	# else
# 	# {
# 	#     $edt->add_condition($action, 'E_LABEL_NOT_FOUND', $record_col, $label) if $action;
# 	#     return 0;
# 	# }
#     }

#     # Otherwise, check if this column supports external identifiers. If it matches the pattern for
#     # an external identifier of the proper type, then we can use the extracted numeric value to
#     # generate a key expression.
    
#     elsif ( my $exttype = $COMMON_FIELD_IDTYPE{$keycol} || get_column_property($table_key, $keycol, 'EXTID_TYPE') )
#     {
# 	# $$$ call validate_extid_value
	
# 	if ( $IDRE{$exttype} && $keyval =~ $IDRE{$exttype} )
# 	{
# 	    if ( defined $2 && $2 > 0 )
# 	    {
# 		return "$keycol='$2'";
# 	    }

# 	    else
# 	    {
# 		$edt->add_condition($action, 'E_RANGE', $record_col,
# 				    "value does not specify a valid record") if $action;
		
# 		return 0;
# 	    }
# 	}

# 	else
# 	{
# 	    $edt->add_condition($action, 'E_EXTID', $keycol);
# 	}
#     }
    
#     # Otherwise, we weren't given a valid value.
    
#     else
#     {
# 	$edt->add_condition($action, 'E_FORMAT', $record_col,
# 			    "value does not correspond to a record identifier") if $action;
# 	return 0;
#     }
# }


# # record_value ( action, table, column )
# # 
# # Return a list of two values. The first is the value from the specified action's record that
# # corresponds to the specified column in the database, or undef if no matching value found. The
# # second is the key under which that value was found in the action record.

# sub record_value {
    
#     my ($edt, $action, $table_key, $col) = @_;
    
#     # First we need to grab the schema for this table, if we don't already have it.
    
#     my $schema;
    
#     # unless ( $schema = $table_keyData::SCHEMA_CACHE{$table_key} )
#     # {
#     # 	my $dbh = $edt->dbh;
#     # 	$schema = get_table_schema($dbh, $table_key, $edt->debug);
#     # }
    
#     # If the action record is not a hashref, then we can return a value only if the operation is
#     # 'delete' and the column being asked for is the primary key. Otherwise, we must return
#     # undef. In either case, we return no second value because there is no column.
    
#     my $record = $action->{record};
    
#     unless ( ref $record eq 'HASH' )
#     {
#         if ( $action->{operation} eq 'delete' && $col eq $action->{keycol} &&
# 	     defined $record )
# 	{
# 	    return $record;
# 	}
	
# 	else
# 	{
# 	    return;
# 	}
#     }
    
#     # If the column is the key column, then we need to check both that column name and the primary
#     # attribute if any.

#     if ( $col eq $action->{keycol} && ! exists $record->{$col} )
#     {
# 	if ( my $alt = get_table_property($table_key, 'PRIMARY_FIELD') )
# 	{
# 	    return ($record->{$alt}, $alt);
# 	}
#     }
    
#     # Otherwise, we need to check for a value under the column name. If there isn't one, then we need to
#     # check the alternate name if any.

#     my $cr = $schema->{$col};

#     if ( exists $record->{$col} && ! $cr->{ALTERNATE_ONLY} )
#     {
# 	return ($record->{$col}, $col);
#     }
    
#     elsif ( my $alt = $cr->{ALTERNATE_NAME} )
#     {
# 	if ( exists $record->{$alt} )
# 	{
# 	    (return $record->{$alt}, $alt);
# 	}
#     }
    
#     # Otherwise, we must return undefined.

#     return;
# }


# # record_has_col ( action, table, column )
# #
# # This is like the previous routine, except that it returns true if the specified column is
# # mentioned in the action record, and false otherwise. The value specified for the column is not
# # checked.

# sub record_has_col {
    
#     my ($edt, $action, $table_key, $col) = @_;
    
#     # First we need to grab the schema for this table, if we don't already have it.
    
#     unless ( my $schema = $TableData::SCHEMA_CACHE{$table_key} )
#     {
# 	my $dbh = $edt->dbh;
# 	$schema = get_table_schema($dbh, $table_key, $edt->debug);
#     }
    
#     # If the action record is not a hashref, then we can return a true only if the operation is
#     # 'delete' and the column being asked for is the primary key. Otherwise, we must return undef.
    
#     my $record = $action->{record};
    
#     unless ( ref $record eq 'HASH' )
#     {
#         return $action->{operation} eq 'delete' && $col eq $action->{keycol} && defined $record;
#     }
    
#     # Otherwise, we need to check for the existence of the column name in the record hash. If it
#     # isn't there, then we need to check the alternate name if any.
    
#     my $cr = $schema->{$col};

#     if ( exists $record->{$col} && ! $cr->{ALTERNATE_ONLY} )
#     {
# 	return 1;
#     }

#     elsif ( $cr->{ALTERNATE_NAME} )
#     {
# 	return exists $record->{$cr->{ALTERNATE_NAME}};
#     }
    
#     else
#     {
# 	return;
#     }
# }


# fetch_old_record ( action, table, key_expr )
# 
# Fetch the old version of the specified record, if it hasn't already been fetched.

sub fetch_old_record {
    
    my ($edt, $action, $table_specifier, $keyexpr) = @_;
    
    $action ||= $edt->{current_action};
    
    if ( my $old = $action->old_record )
    {
	return $old;
    }
    
    $table_specifier ||= $action->table;
    $keyexpr ||= $action->keyexpr;

    if ( $table_specifier && $keyexpr )
    {
	return $action->set_old_record($edt->fetch_record($table_specifier, $keyexpr));
    }

    else
    {
	return;
    }
}


# Action execution routines
# -------------------------

# execute_insert ( action )
#
# Execute an 'insert' action on the database.

sub execute_insert {

    my ($edt, $action) = @_;
    
    # Check to make sure that we have non-empty column/value lists, and that the number of columns
    # and values is equal and non-zero.
    
    my $table_specifier = $action->table;
    my $table_info = $edt->table_info_ref($table_specifier);

    my $cols = $action->column_list;
    my $vals = $action->value_list;
    
    unless ( ref $cols eq 'ARRAY' && ref $vals eq 'ARRAY' && @$cols && @$cols == @$vals )
    {
	$edt->add_condition($action, 'W_EMPTY_RECORD');
	$edt->{skip_count}++;
	$action->set_status('skipped');
	return;
    }
    
    # Construct the INSERT statement.
    
    my $dbh = $edt->dbh;
    
    my $column_string = join(',', @$cols);
    my $value_string = join(',', @$vals);
    
    my $sql = "	INSERT INTO $TABLE{$table_specifier} ($column_string)
		VALUES ($value_string)";
    
    $edt->debug_line("$sql\n") if $edt->debug_mode;
    
    my $do_logging = $table_info->{LOG_CHANGES} || 
	$EditTransaction::LOG_ALL_TABLES && ! $table_info->{NO_LOG_CHANGES};
    
    if ( $do_logging )
{
	$edt->before_log_event($action, 'insert', $table_specifier);
    }
    
    my ($new_keyval);
    
    # Execute the statement inside an eval block, to catch any exceptions that might be thrown.
    
    eval {
	
	$edt->before_action($action, 'insert', $table_specifier);
	
	# Execute the insert statement itself, provided there were no errors and the action
	# was not aborted during the execution of before_action.
	
	if ( $action->can_proceed )
	{
	    my $result = $dbh->do($sql);
	    
	    # If the insert succeeded, get and store the new primary key value. Otherwise, add an
	    # error condition. Unlike update, replace, and delete, if an insert statement fails
	    # that counts as a failure of the action.
	    
	    if ( $result )
	    {
		$new_keyval = $dbh->last_insert_id(undef, undef, undef, undef);
		$action->set_keyval($new_keyval);
		$action->set_resultinfo($new_keyval);
	    }
	    
	    # If we got a non-empty key value, then the insertion succeeded.
	    
	    if ( $new_keyval )
	    {
		# If changes to this table are to be logged, add the appropriate
		# lines to the transaction log variable. They will be written to
		# the log file when (if) the transaction commits.
		
		if ( $do_logging )
		{
		    $edt->log_event($action, 'insert', $table_specifier, $sql, $new_keyval);
		}
		
		# If the action has a label, store the label under the new key
		# value.
		
		if ( my $label = $action->record_value('_label') )
		{
		    $edt->store_label($table_specifier, $new_keyval, $label);
		}
		
		# Call the 'after_action' method. If it doesn't throw an exception,
		# set the action status to 'executed'.
		
		$edt->after_action($action, 'insert', $table_specifier, $new_keyval);
		
		$action->set_status('executed');		
	    }
	    
	    else
	    {
		$edt->add_condition($action, 'E_EXECUTE', 'insert statement failed');
	    }
	}
    };
    
    # If an exception occurred, print it to the error stream and add a corresponding error
    # condition. Any exeption that occurs after the database statement is executed counts as a
    # fatal error for the transaction, because there is no way to go back and undo that statement
    # if PROCEED is in force.
    
    if ( $@ )
    {
	$edt->error_line($@);
	
	if ( $@ =~ /duplicate entry '(.*)' for key '(.*)' at/i )
	{
	    my $value = $1;
	    my $key = $2;
	    $edt->add_condition($action, 'E_DUPLICATE', $value, $key);
	}
	
	else
	{
	    $action->pin_errors if $action->status eq 'executed';
	    $edt->add_condition($action, 'E_EXECUTE', 'an exception occurred during execution');
	}
    };
    
    # If the SQL statement succeeded, increment the executed count.
    
    if ( $action->has_executed && $new_keyval )
    {
	$edt->{exec_count}++;
    }
    
    # Otherwise, set the action status to 'failed' and increment the fail count.
    
    else
    {
	$action->set_status('failed');
	$edt->{fail_count}++;
    }
    
    return;
}


# execute_replace ( action )
#
# Execute an 'replace' action on the database.

sub execute_replace {

    my ($edt, $action) = @_;
    
    # Check to make sure that we actually have column/value lists, and that the number of columns
    # and values is equal and non-zero.
    
    my $table_specifier = $action->table;
    my $table_info = $edt->table_info_ref($table_specifier);
    my $cols = $action->column_list;
    my $vals = $action->value_list;
    
    unless ( ref $cols eq 'ARRAY' && ref $vals eq 'ARRAY' && @$cols && @$cols == @$vals )
    {
	$edt->add_condition($action, 'W_EMPTY_RECORD');
	$edt->{skip_count}++;
	$action->set_status('skipped');
	return;
    }
    
    # Construct the REPLACE statement.
    
    my $dbh = $edt->dbh;
    
    my $column_list = join(',', @$cols);
    my $value_list = join(',', @$vals);
    
    my $sql = "	REPLACE INTO $TABLE{$table_specifier} ($column_list)
		VALUES ($value_list)";
    
    $edt->debug_line("$sql\n") if $edt->debug_mode;
    
    my $do_logging = $table_info->{LOG_CHANGES} || 
	$EditTransaction::LOG_ALL_TABLES && ! $table_info->{NO_LOG_CHANGES};
    
    if ( $do_logging )
    {
	$edt->before_log_event($action, 'replace', $table_specifier);
    }
    
    # Execute the statement inside a try block, to catch any exceptions that might be thrown.
    
    eval {
	
	# If we are logging this action, then fetch the existing record if any.
	
	# unless ( $edt->allows('NO_LOG_MODE') || get_table_property($table_specifier, 'NO_LOG') )
	# {
	#     $edt->fetch_old_record($action, $table_specifier);
	# }
	
	# Start by calling the 'before_action' method.
	
	$edt->before_action($action, 'replace', $table_specifier);
	
	# Then execute the replace statement itself, provided there are no errors and the action
	# was not aborted. If the replace statement returns a zero result and does not throw an
	# exception, that means that the new record was identical to the old one. This is counted
	# as a successful execution, and is marked with a warning.
	
	if ( $action->can_proceed )
	{
	    my $result = $dbh->do($sql);
	    
	    $action->set_result($result);
	    
	    # If changes to this table are to be logged, add the appropriate
	    # lines to the transaction log variable. They will be written to the
	    # log file when (if) the transaction commits.
		
	    if ( $do_logging )
	    {
		$edt->log_event($action, 'replace', $table_specifier, $sql);
	    }
	    
	    # Call the 'after_action' method. If it doesn't throw an exception,
	    # set the action status to 'executed'.
	    
	    $edt->after_action($action, 'replace', $table_specifier, $result);
	    
	    $action->set_status('executed');
	}
    };
    
    # If an exception occurred, print it to the error stream and add a corresponding error
    # condition. Any exeption that occurs after the database statement is executed is
    # automatically a fatal error for the transaction, because there is no way to go back and undo
    # that statement if PROCEED is in force.
    
    if ( $@ )
    {	
	$edt->error_line($@);
	
	if ( $@ =~ /duplicate entry '(.*)' for key '(.*)' at/i )
	{
	    my $value = $1;
	    my $key = $2;
	    $edt->add_condition($action, 'E_DUPLICATE', $value, $key);
	}
	
	else
	{
	    $action->pin_errors if $action->status eq 'executed';
	    $edt->add_condition($action, 'E_EXECUTE', 'an exception occurred during execution');
	}
    }
    
    # If the SQL statement succeeded, increment the executed count.
    
    if ( $action->has_executed )
    {
	$edt->{exec_count}++;
    }
    
    # Otherwise, set the action status to 'failed' and increment fail_count.
    
    else
    {
	$action->set_status('failed');
	$edt->{fail_count}++;
    }
    
    return;
}


# execute_update ( action )
#
# Execute an 'update' action on the database.

sub execute_update {

    my ($edt, $action) = @_;
    
    # Check to make sure that we actually have column/value lists, and that the number of columns
    # and values is equal and non-zero.
    
    my $table_specifier = $action->table;
    my $table_info = $edt->table_info_ref($table_specifier);    
    my $cols = $action->column_list;
    my $vals = $action->value_list;
    
    unless ( ref $cols eq 'ARRAY' && ref $vals eq 'ARRAY' && @$cols && @$cols == @$vals )
    {
	$edt->add_condition($action, 'W_EMPTY_RECORD');
	$edt->{skip_count}++;
	$action->set_status('skipped');
	return;
    }
    
    # Construct the UPDATE statement.
    
    my $dbh = $edt->dbh;
    my $set_list = '';
    
    foreach my $i ( 0..$#$cols )
    {
	$set_list .= ', ' if $set_list;
	$set_list .= "$cols->[$i]=$vals->[$i]";
    }
    
    my $keyexpr = $action->keyexpr;
    
    my $sql = "	UPDATE $TABLE{$table_specifier} SET $set_list
		WHERE $keyexpr";
    
    $edt->debug_line("$sql\n") if $edt->debug_mode;
    
    my $do_logging = $table_info->{LOG_CHANGES} || 
	$EditTransaction::LOG_ALL_TABLES && ! $table_info->{NO_LOG_CHANGES};
    
    if ( $do_logging )
    {
	$edt->before_log_event($action, 'update', $table_specifier);
    }
    
    # Execute the statement inside a try block. If it fails, add either an error or a warning
    # depending on whether this EditTransaction allows PROCEED.
    
    eval {
	
	# If we are logging this action, then fetch the existing record.
	
	# unless ( $edt->allows('NO_LOG_MODE') || get_table_property($table_specifier, 'NO_LOG') )
	# {
	#     $edt->fetch_old_record($action, $table_specifier, $keyexpr);
	# }
	
	# Start by calling the 'before_action' method.
	
	$edt->before_action($action, 'update', $table_specifier);
	
	# Then execute the update statement itself, provided there are no errors and the action
	# has not been aborted. If the update statement returns a result less than the number of
	# matching records, that means at least one updated record was identical to the old
	# one. This is counted as a successful execution, and is marked with a warning.
	
	if ( $action->can_proceed )
	{
	    my $matched;
	    
	    if ( $action->keymult )
	    {
		($matched) = $dbh->selectrow_array("
			SELECT count(*) FROM $TABLE{$table_specifier} WHERE $keyexpr");
	    }
	    
	    my $result = $dbh->do($sql);
	    
	    $result = 0 if $result eq '0E0';
	    
	    if ( $action->keymult )
	    {
		$action->set_resultinfo($result, $matched);
		
		if ( $matched < $action->keyvalues )
		{
		    my $missing = $action->keyvalues - $matched;
		    
		    $edt->add_condition($action, 'W_NOT_FOUND',
					"$missing key value(s) were not found");
		}
		
		if ( $result < $matched )
		{
		    my $unchanged = $matched - $result;
		    
		    $edt->add_condition($action, 'W_UNCHANGED',
				        "$unchanged rows were unchanged by the update");
		}
	    }
	    
	    else
	    {
		$action->set_resultinfo($result, 1);
		
		unless ( $result > 0 )
		{
		    $edt->add_condition($action, 'W_UNCHANGED', 'row was unchanged by the update');
		}
	    }
	    
	    # If changes to this table are to be logged, add the appropriate
	    # lines to the transaction log variable. They will be written to the
	    # log file when (if) the transaction commits.
	    
	    if ( $do_logging )
	    {
		$edt->log_event($action, 'update', $table_specifier, $sql);
	    }
	    
	    # Call the 'after_action' method. If it doesn't throw an exception,
	    # set the action status to 'executed'.
		
	    $edt->after_action($action, 'update', $table_specifier, $result);
	    
	    $action->set_status('executed');
	}
    };
    
    if ( $@ )
    {
	$edt->error_line($@);
	
	if ( $@ =~ /duplicate entry '(.*)' for key '(.*)' at/i )
	{
	    my $value = $1;
	    my $key = $2;
	    $edt->add_condition($action, 'E_DUPLICATE', $value, $key);
	}
	
	else
	{
	    $action->pin_errors if $action->status eq 'executed';
	    $edt->add_condition($action, 'E_EXECUTE', 'an exception occurred during execution');
	}
    };
    
    # If the SQL statement succeeded, increment the executed count.
    
    if ( $action->has_executed )
    {
	$edt->{exec_count}++;
    }
    
    # Otherwise, set the action status to 'failed' and increment fail_count.
    
    else
    {
	$action->set_status('failed');
	$edt->{fail_count}++;
    }
    
    return;
}


# execute_delete ( action )
#
# Execute a 'delete' action on the database.

sub execute_delete {

    my ($edt, $action) = @_;
    
    # Construct the DELETE statement.
    
    my $dbh = $edt->dbh;
    my $table_specifier = $action->table;
    my $table_info = $edt->table_info_ref($table_specifier);
    my $keyexpr = $action->keyexpr;
    my $found;
    
    my $sql = "	DELETE FROM $TABLE{$table_specifier} WHERE $keyexpr";
    
    $edt->debug_line( "$sql\n" ) if $edt->debug_mode;
    
    my $do_logging = $table_info->{LOG_CHANGES} || 
	$EditTransaction::LOG_ALL_TABLES && ! $table_info->{NO_LOG_CHANGES};
    
    if ( $do_logging )
    {
	$edt->before_log_event($action, 'replace', $table_specifier);
    }
    
    # Execute the statement inside a try block. If it fails, add either an error or a warning
    # depending on whether this EditTransaction allows PROCEED.
    
    eval {
	
	# If we are logging this action, then fetch the existing record.
	
	# unless ( $edt->allows('NO_LOG_MODE') || get_table_property($table_specifier, 'NO_LOG') )
	# {
	#     $edt->fetch_old_record($action, $table_specifier, $keyexpr);
	# }
	
	# Start by calling the 'before_action' method. This is designed to be overridden by
	# subclasses, and can be used to do any necessary auxiliary actions to the database. The
	# default method does nothing.    
	
	$edt->before_action($action, 'delete', $table_specifier);
	
	# Then execute the delete statement itself, provided the action has not
	# been aborted. If we are operationg on multiple records, figure out how
	# many there are.
	
	if ( $action->can_proceed )
	{
	    my $result = $dbh->do($sql);
	    
	    $action->set_resultinfo($result, $result);
	    
	    $result = "0" if $result eq "0E0";
	    
	    if ( $action->keymult )
	    {
		if ( $result < $action->keyvalues )
		{
		    my $missing = $action->keyvalues - $result;
		    
		    $edt->add_condition($action, 'W_NOT_FOUND', "$missing key values(s) were not found");
		}
	    }
	    
	    elsif ( ! $result )
	    {
		$edt->add_condition($action, 'W_NOT_FOUND', "the specified key value was not found");
	    }
	    
	    # If changes to this table are to be logged, add the appropriate
	    # lines to the transaction log variable. They will be written to the
	    # log file when (if) the transaction commits.
	    
	    if ( $do_logging )
	    {
		$edt->log_event($action, 'delete', $table_specifier, $sql);
	    }
	    
	    # Call the 'after_action' method. If it doesn't throw an exception,
	    # set the action status to 'executed'.
	    
	    $edt->after_action($action, 'delete', $table_specifier, $result);
	    
	    $action->set_status('executed');
	}
    };
    
    if ( $@ )
    {	
	$edt->error_line($@);
	$action->pin_errors if $action->status eq 'executed';
	$edt->add_condition($action, 'E_EXECUTE', 'an exception occurred during execution');
    };
    
    # If the SQL statement succeeded, increment the executed count.
    
    if ( $action->has_executed )
    {
	$edt->{exec_count}++;
    }
    
    # Otherwise, set the action status to 'failed' and increment the failed count.
    
    else
    {
	$action->set_status('failed');
	$edt->{fail_count}++;
    }
    
    return;
}


# execute_delete_cleanup ( action )
# 
# Perform a delete operation on the database. The records to be deleted are those that match the
# action selector and were not either inserted, updated, or replaced during this transaction.

sub execute_delete_cleanup {

    my ($edt, $action) = @_;
    
    # my $table_key = $action->table;
    
    # my $dbh = $edt->dbh;
    
    # my $selector = $action->selector;
    # my $keycol = $action->keycol;
    
    # # Come up with the list of keys to preserve. If there aren't any entries, add a 0 to avoid a
    # # syntax error. This will not match any records under the Paleobiology Database convention
    # # that 0 is never a valid key.
    
    # my @preserve;	# $$$ this needs to be rewritten.
    
    # push @preserve, @{$edt->{inserted_keys}{$table_key}} if ref $edt->{inserted_keys}{$table_key} eq 'ARRAY';
    # push @preserve, @{$edt->{updated_keys}{$table_key}} if ref $edt->{updated_keys}{$table_key} eq 'ARRAY';
    # push @preserve, @{$edt->{replaced_keys}{$table_key}} if ref $edt->{replaced_keys}{$table_key} eq 'ARRAY';
    
    # push @preserve, '0' unless @preserve;
    
    # my $key_list = join(',', @preserve);
    
    # my $keyexpr = "$selector and not $keycol in ($key_list)";
    
    # # Figure out which keys will be deleted, so that we can list them later.

    # # my $init_sql = "	SELECT $keycol FROM $TABLE{$table_key} WHERE $keyexpr";
    
    # # $edt->debug_line( "$init_sql\n" ) if $edt->{debug_mode};

    # # my $deleted_keys = $dbh->selectcol_arrayref($init_sql);
    
    # # If the following flag is set, deliberately generate an SQL error for
    # # testing purposes.
    
    # if ( $TEST_PROBLEM{sql_error} )
    # {
    # 	$keyexpr .= 'XXXX';
    # }
    
    # # Then construct the DELETE statement.
    
    # $action->set_keyexpr($keyexpr);
    
    # # my $sql = "	DELETE FROM $TABLE{$table_key} WHERE $keyexpr";
    
    # # $edt->debug_line( "$sql\n" ) if $edt->{debug_mode};
    
    # # Execute the statement inside a try block. If it fails, add either an error or a warning
    # # depending on whether this EditTransaction allows PROCEED.
    
    # eval {
	
    # 	# If we are logging this action, then fetch the existing record.
	
    # 	# unless ( $edt->allows('NO_LOG_MODE') || get_table_property($table_key, 'NO_LOG') )
    # 	# {
    # 	#     $edt->fetch_old_record($action, $table_key, $keyexpr);
    # 	# }
	
    # 	# Start by calling the 'before_action' method. This is designed to be overridden by
    # 	# subclasses, and can be used to do any necessary auxiliary actions to the database. The
    # 	# default method does nothing.    
	
    # 	$edt->before_action($action, 'delete_cleanup', $table_key);
	
    # 	# Then execute the delete statement itself, provided there are no errors and the action
    # 	# has not been aborted.
	
    # 	if ( $action->can_proceed )
    # 	{
    # 	    # my $result = $dbh->do($sql);
	    
    # 	    $action->set_status('executed');
    # 	    $action->set_result($result);
    # 	    $action->_confirm_keyval($deleted_keys);   # $$$ needs to be rewritten
	    
    # 	    $edt->after_action($action, 'delete_cleanup', $table_key, $result);
    # 	}
    # };
    
    # if ( $@ )
    # {	
    # 	$edt->error_line($@);
    # 	$action->pin_errors if $action->status eq 'executed';
    # 	$edt->add_condition($action, 'E_EXECUTE', 'an exception occurred during execution');
    # };
    
    # # If the SQL statement succeeded, increment the executed count.
    
    # if ( $action->has_executed )
    # {
    # 	$edt->{exec_count}++;
    # }
    
    # # Otherwise, set the action status to 'failed' unless the action was aborted before execution.
    
    # elsif ( $action->status ne 'aborted' )
    # {
    # 	$action->set_status('failed');
    # 	$edt->{fail_count}++;
    # }
    
    return;
}


# execute_other ( action )
# 
# Perform an operation other than insert, replace, update, or delete on the database. The keys
# and values have been checked previously.

sub execute_other {

    my ($edt, $action) = @_;
    
    my $table_specifier = $action->table;
    my $table_info = $edt->table_info_ref($table_specifier);
    
    # Determine the method to be called.
    
    my $method = $action->method;
    
    # Call the specified method inside a try block. If it fails, add either an error or
    # a warning depending on whether this EditTransaction allows PROCEED.
    
    eval {
	
	$edt->before_action($action, $method, $table_specifier);

	if ( $action->can_proceed )
	{
	    my $result = $edt->$method($action, $table_specifier, $action->record);
	    
	    $action->set_result($result);
	    
	    # Call the 'after_action' method. If it doesn't throw an exception,
	    # set the action status to 'executed'.
		
	    $edt->after_action($action, $method, $table_specifier, $result);
	    
	    $action->set_status('executed');
	}
    };
    
    if ( $@ )
    {
	$edt->error_line($@);
	$action->pin_errors if $action->status eq 'executed';
	$edt->add_condition($action, 'E_EXECUTE', 'an exception occurred during execution');
    }
    
    # If the SQL statement succeeded, increment the executed count.
    
    if ( $action->has_executed )
    {
	$edt->{exec_count}++;
    }
    
    # Otherwise, set the action status to 'failed' and increment fail_count.
    
    else
    {
	$action->set_status('failed');
	$edt->{fail_count}++;
    }
    
    return;
}


# _execute_sql_action ( action, table, record )
#
# Execute the specified SQL statement.

sub _execute_sql_action {
    
    my ($edt, $action, $table_key, $record) = @_;
    
    my $sql_stmt = $record->{sql};
    my $store_it = $record->{store_result};
    
    croak "no sql statement to execute" unless $sql_stmt;

    $edt->debug_line("$sql_stmt\n") if $edt->{debug_mode};
    
    my $result = $edt->{dbh}->do($sql_stmt);

    if ( $store_it )
    {
	if ( ref $store_it eq 'SCALAR' )
	{
	    $store_it->$* = $result;
	}
	
	elsif ( ref $store_it eq 'ARRAY' )
	{
	    push $store_it->@*, $result;
	}
	
	elsif ( ref $store_it eq 'CODE' )
	{
	    $store_it->($result);
	}
    }

    return $result;
}


# log_event ( action, operation, table, sql, key_value )
# 
# This routine logs changes to the database tables. It can be overridden by
# included modules.

sub log_event {
    
    my ($edt, $action, $op, $table_specifier, $sql, $key_value) = @_;
    
    return unless $EditTransaction::LOG_FILENAME;
    return if $edt->allows('NO_LOG_MODE');
    
    my ($sec,$min,$hour,$mday,$mon,$year) = localtime(time);
    my $datestr = sprintf("%04d-%02d-%02d", $year + 1900, $mon + 1, $mday);
    my $timestr = sprintf("%02d:%02d:%02d", $hour, $min, $sec);
    
    $key_value //= $action->keyval // '?';
    
    $sql =~ s/ NOW[(][)] / "'$datestr $timestr'" /ixeg;
    $sql =~ s/^\s+//;
    
    my $line1 = "# " . join(' | ', "$datestr $timestr", uc $op, $TABLE{table_specifier}, $key_value) 
	. "\n";
    my $line2 = "$sql;\n";
    
    $edt->{log_lines} .= $line1 . $line2;
    $edt->{log_date} = $datestr;
}


# before_log_event ( action, operation, table )
# 
# This default routine does nothing. It can be overridden by included modules.

sub before_log_event {
    
}


# log_aux_event ( operation, table, sql, key_value )
# 
# This routine logs changes to auxiliary database tables that hold lists of
# records relating to primary tables.

sub log_aux_event {
    
    my ($edt, $op, $table_specifier, $sql, $key_col, $key_value) = @_;
    
    return unless $EditTransaction::LOG_FILENAME;
    return if $edt->allows('NO_LOG_MODE');
    
    my ($sec,$min,$hour,$mday,$mon,$year) = localtime(time);
    my $datestr = sprintf("%04d-%02d-%02d", $year + 1900, $mon + 1, $mday);
    my $timestr = sprintf("%02d:%02d:%02d", $hour, $min, $sec);
    
    $key_value //= '?';
    
    $sql =~ s/ NOW[(][)] / "'$datestr $timestr'" /ixeg;
    $sql =~ s/^\s+//;
    
    my $line1 = "# " . join(' | ', "$datestr $timestr", uc $op, $TABLE{table_specifier}, $key_value) 
	. "\n";
    my $line2 = "$sql;\n";
    
    $edt->{log_lines} .= $line1 . $line2;
    $edt->{log_date} = $datestr;
}


# write_log ( )
# 
# Write the log data for this transaction to the specified file.

sub write_log {
    
    my ($edt) = @_;
    
    my $logfile;
    my $logname = $EditTransaction::LOG_FILENAME =~ s/DATE/$edt->{log_date}/r;
    
    unless ( open($logfile, ">>", $logname) )
    {
	my_error("cannot open $logname: $!", $edt->{log_lines});
	return;
    }
    
    unless ( my_lock($logfile) )
    {
	my_error("cannot lock or seek $logname: $!", $edt->{log_lines});
	return;
    }
    
    print $logfile encode_utf8($edt->{log_lines});
    
    unless ( my_unlock($logfile) )
    {
	my_error("cannot unlock $logname: $!");
    }
    
    close($logfile) or my_error("closing $logname: $!");
}


sub my_lock {
    
    my ($fh) = @_;
    
    # Try to obtain the lock.  If unsuccessful, try up to three times sleeping
    # for one second between tries.
    
    foreach my $tries (1..3)
    {
	# If we are able to get the lock, return the result of the seek
	# operation (true if successful, false otherwise).
	
	if ( flock($fh, LOCK_EX | LOCK_NB) )
	{
	    return seek($fh, 0, SEEK_END);
	}
	
	sleep(1) unless $tries == 3;
    }
    
    # Return false, we were unable to obtain the lock.
    
    return;
}


# my_unlock ( fh )
# 
# Release the advisory lock on the given file.

sub my_unlock {
    
    my ($fh) = @_;
    
    return flock($fh, LOCK_UN);
}


# my_error ( errmsg, log_record )
# 
# This routine is called if an error occurred while writing to the datalog.
# Print the specified message to STDERR, which will generally result in it
# ending up in the web server's error log file.  Also print the log record to
# STDERR, so we have some chance of finding it and putting it back in the
# proper place in the data log.
# 
# We hope this routine will not get called very often, maybe not at all.

sub my_error {
    
    my ($errmsg, $log_record) = @_;
    
    print STDERR "DATALOG ERROR: $errmsg\n";
    print STDERR encode_utf8($log_record);
    print STDERR "# =\n";
}

1;
