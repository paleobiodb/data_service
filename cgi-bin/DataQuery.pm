#
# DataQuery
# 
# A base class that implements a data service for the PaleoDB.  This can be
# subclassed to produce any necessary data service.  For examples, see
# TaxonQuery.pm and CollectionQuery.pm. 
# 
# Author: Michael McClennen

package DataQuery;

use strict;

use Encode;



# new ( dbh )
# 
# Generate a new query object, using the given database handle.

sub new {
    
    my ($class, $dbh, $format) = @_;
    my $self = { dbh => $dbh };
    
    return bless $self, $class;
}


# setParameters ( params )
# 
# Accepts a hash of parameter values, filters them for correctness, and sets
# the appropriate fields of the query object.  It is designed to be called
# from a Dancer route, although that is not a requirement.
# 
# This method handles only parameters that are common to the various queries
# implemented by this class and its subclasses.  Subclasses should override
# this method, in order to recognize their particular parameters, and then
# call this routine explicitly to recognize and set the common parameters.

sub setParameters {

    my ($self, $params) = @_;
    
    # The 'limit' parameter, if given, limits the size of the result set.  If
    # not specified, or not greater than zero, a default limit of 500 will be
    # used.  If 'all' is specified as the value, then the full result set will
    # be returned.
    
    if ( defined $params->{limit} && lc $params->{limit} eq 'all' )
    {
	$self->{limit} = 0;	    # the query routine will interpret
    }                               # this as "no limit";
    
    elsif ( defined $params->{limit} && $params->{limit} >= 0 )
    {
	$self->{limit} = $params->{limit} + 0;
    }
    
    else
    {
	$self->{limit} = 'default';
    }
    
    # The 'ct' parameter sets the output format.  This must be specified in
    # all cases.  Depending on the content type, we select the appropriate set
    # of routines for generating the response body from the query result.
    
    if ( defined $params->{ct} )
    {
	my $ct = lc $params->{ct};
	
	if ( $ct eq 'xml' ) {
	    $self->{output_format} = 'xml';
	}
	
	elsif ( $ct eq 'json' ) {
	    $self->{output_format} = 'json';
	}
    }
}


# generateSingleResult ( )
# 
# Return the query result formatted as a single string according to the output
# format previously set by setOutputFormat().

sub generateSingleResult {

    my ($self) = @_;
    
    $self->{row_count} = 1;
    
    return $self->generateHeader() . $self->generateRecord($self->{main_row}, 1) .
	    $self->generateFooter();
}


# generateCompoundResult ( options )
# 
# Return the query result formatted as a single string according to the output
# format previously set by setOutputFormat().  The only option available at
# this time is:
# 
#   can_stream => 1
# 
# This option can be used to inform this function that it should stream the
# result unless the result is very small.  This option should only be used if
# the server does in fact support streaming.  If the size of the result will
# exceed 100 kilobytes, the result computed so far is stashed in the query
# object and the function returns false.  The calling application can then
# setup a call to streamResult to send the stashed data followed by the rest
# of the data as it is retrieved from the database.

sub generateCompoundResult {

    my ($self, %options) = @_;
    
    my $sth = $self->{main_sth};
    my $output = '';
    my $is_first_row = 1;
    my $row;
    
    $self->{row_count} = 0;
    
    my $initial = $self->initOutput();
    $output .= $initial if defined $initial;
    
    while ( $row = $sth->fetchrow_hashref )
    {
	$self->processRecord($row);
	$output .= $self->generateRecord($row, $is_first_row);
	$is_first_row = 0;
	$self->{row_count}++;
	
	if ( defined $options{can_stream} && length($output) > 102400 )
	{
	    $self->{stashed_output} = $output;
	    return;
	}
    }
    
    my $final = $self->finishOutput();
    $output .= $final if defined $final;
    
    return $self->generateHeader() . $output . $self->generateFooter();
}


# streamResult ( )
# 
# Generate the query result formatted according to the output format
# previously set by setOutputFormat().  This routine should only be called if
# generateCompoundOutput returned false.  It is passed a 'writer' object, to
# which the stashed output from generateCompoundResult, each record in turn,
# and then the footer is written.

sub streamResult {
    
    my ($self, $writer) = @_;
    
    my $sth = $self->{main_sth};
    my $row;
    
    # First send out the partial output generated by generateCompoundResult(),
    # which has been stashed in $self->{stashed_output}.
    
    $writer->write( encode_utf8($self->{stashed_output}) );
    
    # Then generate the remaining output.
    
    while ( $row = $sth->fetchrow_hashref )
    {
	$self->processRecord($row);
	$writer->write( encode_utf8($self->generateRecord($row)) );
    }
    
    my $final = $self->finishOutput();
    
    $writer->write( $final ) if defined $final;
    $writer->write( $self->generateFooter() );
    $writer->close();
}


# Following are defaults for the output routines.  These can be overridden.

# generateHeader ( )
# 
# Generate the proper header for the requested output format.

sub generateHeader {
    
    my ($self) = @_;
    
    return $self->generateHeaderXML if $self->{output_format} eq 'xml';
    return $self->generateHeaderJSON;
}


# generateHeaderXML ( )
# 
# Return the proper header for an XML document in Darwin Core format.

sub generateHeaderXML {

    my ($self) = @_;
    
    return <<END_XML;
<?xml version="1.0" standalone="yes"?>
<dwr:DarwinRecordSet xmlns:dcterms="http://purl.org/dc/terms/" xmlns:dwc="http://rs.tdwg.org/dwc/terms/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dwr="http://rs.tdwg.org/dwc/dwcrecord/" xmlns:dc="http://purl.org/dc/elements/1.1/" xsi:schemaLocation="http://rs.tdwg.org/dwc/dwcrecord/ http://rs.tdwg.org/dwc/xsd/tdwg_dwc_classes.xsd">
END_XML

}


# generateHeaderJSON ( )
# 
# Return a string that will be valid as the beginning of a JSON result.

sub generateHeaderJSON {

    my ($self) = @_;
    
    my $output = '{' . "\n";
    
    if ( defined $self->{object_class} )
    {
	$output .= '"class":' . $self->{object_class} . ",\n";
    }
    
    if ( defined $self->{row_count} )
    {
	$output .= '"count":' . ($self->{row_count} + 0) . ",\n";
    }
    
    elsif ( defined $self->{total_count} )
    {
	if ( defined $self->{limit} && $self->{limit} < $self->{total_count} )
	{
	    $output .= '"count":' . ($self->{limit} + 0) . ",\n";
	    $output .= '"total_count":' . ($self->{total_count} + 0) . ",\n";
	}
	else
	{
	    $output .= '"count": ' . ($self->{total_count} + 0) . ",\n";
	}
    }
    
    $output .= '"data": [';
    return $output;
}


# generateFooter ( )
# 
# Generate the proper footer for the requested output format.

sub generateFooter {
    
    my ($self) = @_;
    
    return $self->generateFooterXML if $self->{output_format} eq 'xml';
    return $self->generateFooterJSON;
}


# generateFooterXML ( )
# 
# Return the proper footer for an XML document in Darwin Core format.

sub generateFooterXML {

    return <<END_XML;
</dwr:DarwinRecordSet>
END_XML

}


# generateFooterJSON ( )
# 
# Return a string that will be valid as the end of a JSON result, after the
# header and zero or more records.

sub generateFooterJSON {
    
    my ($self) = @_;
    
    return "\n]\n}\n";
}


# initOutput ( )
# 
# This method is intended to be overridden.  It is called before the first
# record is generated, and if it returns a string that string is appended to
# the output just after the header and before the first record.

sub initOutput {

}


# finishOutput ( )
# 
# This method is intended to be overridden.  It is called after the last
# record is generated, and if it returns a string that string is appended to
# the output just after the last record and before the header.

sub finishOutput {

}


# processRow ( )
# 
# This method is intended to be overridden.  It is called once for each row,
# after the row is fetched but before the row's output is generated.  The row
# hash is given as the first argument.

sub processRow {

}


# Following are some utility routines.

# xml_clean ( string )
# 
# Given a string value, return an equivalent string value that will be valid
# as part of an XML document.

my (%ENTITY) = ( '&' => '&amp;', '<' => '&lt;', '>', '&gt;' );

sub xml_clean {
    
    my ($string, $preserve_tags) = @_;
    
    # Do nothing unless our first argument is defined
    
    return unless defined $string;
    
    # First, turn any numeric character references into actual Unicode
    # characters.  The database does contain some of these.
    
    $string =~ s/&\#(\d)+;/pack("U", $1)/eg;
    
    # Next, rename any instance of & that doesn't start a valid character
    # entity reference to &amp; and rename all < and > to &lt; and &gt;
    
    $string =~ s/(&(?!\w+;)|<|>)/$ENTITY{$1}/ge;
    
    # Finally, delete all control characters (they shouldn't be in the database
    # in the first place, but unfortunately some rows do contain them).
    
    $string =~ s/[\0-\037\177]//g;
    
    return $string;
}


# json_clean ( string )
# 
# Given a string value, return an equivalent string value that will be valid
# as part of a JSON result.

my (%ESCAPE) = ( '\\' => '\\\\', '"' => '\\"', "\t" => '\\t', "\n" => '\\n',
		 "\r" => '\\r' );	#'

sub json_clean {
    
    my ($string) = @_;
    
    # Do nothing unless our first argument is defined
    
    return unless defined $string;
    
    # First, turn any numeric character references into actual Unicode
    # characters.  The database does contain some of these.
    
    $string =~ s/&\#(\d)+;/pack("U", $1)/eg;
    
    # Next, escape all backslashes, double-quotes and whitespace control characters
    
    $string =~ s/(\\|\"|\n|\t|\r)/$ESCAPE{$1}/ge;
    
    # Finally, delete all other control characters (they shouldn't be in the
    # database in the first place, but unfortunately some rows do contain
    # them).
    
    $string =~ s/[\0-\037\177]//g;
    
    return $string;
}


# add_reference ( )
# 
# Process the fields that define a publication reference

sub add_reference {

    my ($self, $row) = @_;
    
    # First format the author string.  This includes stripping extra periods
    # from initials and dealing with "et al" where it occurs.
    
    my $a1i = $row->{r_a1i} || '';
    my $a1l = $row->{r_a1l} || '';
    
    $a1i =~ s/\.//g;
    $a1i =~ s/([A-Za-z])/$1./g;
    
    my $auth1 = $a1i;
    $auth1 .= ' ' if $a1i ne '' && $a1l ne '';
    $auth1 .= $a1l;
    
    my $a2i = $row->{r_a2i} || '';
    my $a2l = $row->{r_a2l} || '';
    
    $a2i =~ s/\.//g;
    $a2i =~ s/([A-Za-z])/$1./g;
    
    my $auth2 = $a2i;
    $auth2 .= ' ' if $a2i ne '' && $a2l ne '';
    $auth2 .= $a2l;
    
    my $auth3 = $row->{r_otherauthors} || '';
    
    $auth3 =~ s/\.//g;
    $auth3 =~ s/\b(\w)\b/$1./g;
    
    # Then construct the author string
    
    my $authorstring = $auth1;
    
    if ( $auth2 =~ /et al/ )
    {
	$authorstring .= " $auth2";
    }
    elsif ( $auth2 ne '' && $auth3 ne '' )
    {
	$authorstring .= ", $auth2";
	if ( $auth3 =~ /et al/ )
	{
	    $authorstring .= " $auth3";
	}
	else
	{
	    $authorstring .= ", and $auth3";
	}
    }
    elsif ( $auth2 )
    {
	$authorstring .= " and $auth2";
    }
    
    # Now start building the reference with authorstring, publication year,
    # reference title and publication title
    
    my $longref = $authorstring;
    
    if ( $authorstring ne '' )
    {
	$longref .= '.' unless $authorstring =~ /\.$/;
	$longref .= ' ';
    }
    
    my $pubyr = $row->{r_pubyr} || '';
    
    if ( $pubyr ne '' )
    {
	$longref .= "$pubyr. ";
    }
    
    my $reftitle = $row->{r_reftitle} || '';
    
    if ( $reftitle ne '' )
    {
	$longref .= $reftitle;
	$longref .= '.' unless $reftitle =~ /\.$/;
	$longref .= ' ';
    }
    
    my $pubtitle = $row->{r_pubtitle} || '';
    my $editors = $row->{r_editors} || '';
    
    if ( $pubtitle ne '' )
    {
	my $pubstring = "<i>$pubtitle</i>";
	
	if ( $editors =~ /,| and / )
	{
	    $pubstring = " In $editors (eds.), $pubstring";
	}
	elsif ( $editors )
	{
	    $pubstring = " In $editors (ed.), $pubstring";
	}
	
	$longref .= $pubstring . " ";
    }
    
    # Now add volume and page number information if available
    
    my $pubvol = $row->{r_pubvol} || '';
    my $pubno = $row->{r_pubno} || '';
    
    if ( $pubvol ne '' || $pubno ne '' )
    {
	$longref .= '<b>';
	$longref .= $pubvol if $pubvol ne '';
	$longref .= "($pubno)" if $pubno ne '';
	$longref .= '</b>';
    }
    
    my $fp = $row->{r_fp} || '';
    my $lp = $row->{r_lp} || '';
    
    if ( ($pubvol ne '' || $pubno ne '') && ($fp ne '' || $lp ne '') )
    {
	$longref .= ':';
	$longref .= $fp if $fp ne '';
	$longref .= '-' if $fp ne '' && $lp ne '';
	$longref .= $lp if $lp ne '';
    }
    
    $row->{pubref} = $longref if $longref ne '';
    
    if ( $longref ne '' )
    {
	$row->{pubref} = $longref;
    }
}


1;
