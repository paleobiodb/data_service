package PAST::Util;
use strict;

# Takes output from from the parseDownloadFile routine below and builds a binary
# presence matrix with collections in rows and taxa in columns. Returns 3 arrays references
# marshalled togther:
#  first array is a single array corresponding to the column header (list of taxa)
#  second is row header (list of collections)
#  third is double array thats the actual matrix
sub binaryPresenceMatrix {
    my ($header_ref,$data_ref) = @_;
    my %header = %{$header_ref};
    my @data = @{$data_ref};

    my $genus_dl_idx = $header{'occurrences.genus_name'};
    my $subgenus_dl_idx = $header{'occurrences.subgenus_name'};
    my $species_dl_idx = $header{'occurrences.species_name'};
    my $coll_dl_idx = $header{'collection_no'};
    # also construct a two-dimensional hash that stores the extra (contextual)
    #  data about the collections
    # first we need to know their names and column numbers
    my @extra_field_cols;
    my @extra_field_names;
    for my $h ( keys %header )	{
      if ( $h =~ /collections/ )	{
        push @extra_field_cols , $header{$h};
        my $field_name = $h;
        $field_name =~ s/collections\.//;
        push @extra_field_names , $field_name;
      }
    }

    my $data_rows = scalar(@data);
    my %seen_taxon = ();
    my %seen_coll = ();
    my @taxon_header = ();
    my @coll_header = ();
    my @matrix;
    my %extra_data = ();
    for(my $i=0;$i<$data_rows;$i++) {
        my $collection = $data[$i][$coll_dl_idx];
        my $taxon_name = $data[$i][$genus_dl_idx];
        if ($species_dl_idx) {
            $taxon_name .= " ".$data[$i][$species_dl_idx];
        }
        for my $h (0..$#extra_field_cols)	{
          $extra_data{$collection}{$extra_field_names[$h]} = $data[$i][$extra_field_cols[$h]];
        }
        # If we haven't seen the collection before, add it on to the end
        # else lookup its index in our matrix
        my ($coll_matrix_idx,$taxon_matrix_idx);
        if (! exists $seen_coll{$collection}) {
            $coll_matrix_idx = scalar(@coll_header);
            $seen_coll{$collection} = $coll_matrix_idx;
            $coll_header[$coll_matrix_idx] = $collection;
        } else {
            $coll_matrix_idx = $seen_coll{$collection};
        }
        if (! exists $seen_taxon{$taxon_name}) {
            $taxon_matrix_idx = scalar(@taxon_header);
            $seen_taxon{$taxon_name} = $taxon_matrix_idx;
            $taxon_header[$taxon_matrix_idx] = $taxon_name;
        } else {
            $taxon_matrix_idx = $seen_taxon{$taxon_name}; 
        }
        $matrix[$coll_matrix_idx][$taxon_matrix_idx] = 1;
    }

    my %taxon_position;
    for my $i (0..$#taxon_header)	{
        $taxon_position{$taxon_header[$i]} = $i;
    }
    @taxon_header = sort { $a cmp $b } @taxon_header;

    my @new_matrix;
    for my $i (0..$#coll_header)	{
        for my $j (0..$#taxon_header)	{
            $new_matrix[$i][$j] = $matrix[$i][$taxon_position{$taxon_header[$j]}];
        }
    }
    @matrix = @new_matrix;

    return (\@coll_header,\@taxon_header,\@matrix,\%extra_data);
}

# Generic parsing routine
# Parses file generated by PBDB download and returns reference to entire
# downloaded file.  Return a marshalled (%header,@data) or nothing if
# something goes wrong
#   %header is a hash where keys are equal to the names of the header, and values
#     equal to the index into the @data array.  
#   @data is a double array. first index is row offset, second is column
sub parseTextFile {
    my $filename = shift;

    my $sepChar = ",";
    if ($filename =~ /tab$/) {
        $sepChar = "\t";
    } 
    
    my $csv = Text::CSV_XS->new({
        'quote_char'  => '"',
        'escape_char' => '"',
        'sep_char'    => $sepChar,
        'binary'      => 1
    });


    if ( ! open OCCS,"<$filename" ) {
        print "<h3>The data can't be analyzed because you haven't yet downloaded a data file of occurrences <a href=\"/cgi-bin/bridge.pl?action=displayDownloadForm\">Download the data again</a> and make sure to check off the fields you want in the \"Collection fields\" part of the form.</h3>\n";
        return ();
    } 

    my @data;
    my %header;

    my $row = <OCCS>;
    my $status = $csv->parse($row);
    if (!$status) { 
        die "Warning, error parsing CSV line 0";
    }
    my @header_names = $csv->fields();
    for(my $i=0;$i<scalar(@header_names);$i++) {
        $header{$header_names[$i]} = $i;
    }
    my $row_cnt = 0;
    my $col_cnt = scalar(@header_names);
    while ($row = <OCCS>) {
        my $status = $csv->parse($row);
        if (!$status) { 
            die "Warning, error parsing CSV line 0";
        }
        my @row = $csv->fields();
        $data[$row_cnt] = \@row;
        $row_cnt++;
    }

    return (\%header,\@data);
}

1;
