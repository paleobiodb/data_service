<!DOCTYPE html>
<meta charset="utf-8">
<style>

circle {
  stroke: #fff;
}
.leader {
  stroke:#000;
  stroke-width:2px;
}

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

var peopleGraph = {
  "init": function() {
    var margin = {top: 0, right: 0, bottom: 0, left: 0},
        width = 750 - margin.left - margin.right,
        height = 660 - margin.top - margin.bottom,
        n = 200,
        m = 10;
        nodes = [];

    var legend = d3.select("#peopleChartLegend").append("svg")
        .attr("height", 50)
        .attr("width", 250);

      legend.append("circle")
        .attr("r", 20)
        .attr("cx", 25)
        .attr("cy", 25)
        .attr("fill", "none")
        .attr("class", "leader");

      legend.append("text")
        .attr("x", 55)
        .attr("y", 40)
        .text("Holds leadership position");

      d3.json("people_sans_members.json", function(err, data) {
          data = data.children;
          for (var i=0; i<data.length;i++) {
            for(var j=0; j<data[i].children.length; j++) {
              data[i].children[j].type = data[i].name;
              data[i].children[j].radius = 54;
              data[i].children[j].color = peopleGraph.getFill(data[i].children[j].type);
              nodes.push(data[i].children[j]);
            }
          }

        var force = d3.layout.force()
            .nodes(nodes)
            .size([width, height])
            .gravity(.1)
            .charge(0)
            .on("tick", peopleGraph.tick)
            .start();

        var svg = d3.select("body").append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
          .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

          circle = svg.selectAll("circle")
            .data(nodes)
          .enter().append("g")
            .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; })
            .call(force.drag);

          circle.append("circle")
            .attr("r", function(d) { return d.radius; })
            .style("fill", function(d) { return d.color; })
            .attr("class", function(d) {
              if (d.role) {
                return "leader";
              }
            })

          circle.append("text")
            .attr("text-anchor", "middle")
            .text(function(d) { return d.name; })
            .style("font-size", "24px") // initial guess
            .style("font-size", function(d) { return (2 * d.radius - 8) / this.getComputedTextLength() * 24 + "px"; });

          circle.append("title")
            .text(function(d) {return d.name + " - " + d.institute;});

        }); // end JSON callback
  },
  "getFill": function(type) {
    switch(type) {
      case "Executive Committee":
        return "#985144";
      case "Tech Team":
        return "#489FB2";
      case "Advisory Board":
        return "#8DA0CB";
      case "Members":
        return "#66C2A5";
    }
  },
  "tick": function(e) {
    circle
      .each(peopleGraph.cluster(10 * e.alpha * e.alpha))
      .each(peopleGraph.collide(.5))
      .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; })
  },
  "cluster": function(alpha) {
    var max = {};

    // Find the largest node for each cluster.
    nodes.forEach(function(d) {
      if (!(d.color in max) || (d.radius > max[d.color].radius)) {
        max[d.color] = d;
      }
    });

    return function(d) {
      var node = max[d.color],
          l,
          r,
          x,
          y,
          i = -1;

      if (node == d) return;

      x = d.x - node.x;
      y = d.y - node.y;
      l = Math.sqrt(x * x + y * y);
      r = d.radius + node.radius;
      if (l != r) {
        l = (l - r) / l * alpha;
        d.x -= x *= l;
        d.y -= y *= l;
        node.x += x;
        node.y += y;
      }
    };
  },
  "collide": function(alpha) {
    var radius = d3.scale.sqrt().range([0, 12]),
        padding = 6;
        quadtree = d3.geom.quadtree(nodes);

    return function(d) {
      var r = d.radius + radius.domain()[1] + padding,
          nx1 = d.x - r,
          nx2 = d.x + r,
          ny1 = d.y - r,
          ny2 = d.y + r;
      quadtree.visit(function(quad, x1, y1, x2, y2) {
        if (quad.point && (quad.point !== d)) {
          var x = d.x - quad.point.x,
              y = d.y - quad.point.y,
              l = Math.sqrt(x * x + y * y),
              r = d.radius + quad.point.radius + (d.color !== quad.point.color) * padding;
          if (l < r) {
            l = (l - r) / l * alpha;
            d.x -= x *= l;
            d.y -= y *= l;
            quad.point.x += x;
            quad.point.y += y;
          }
        }
        return x1 > nx2
            || x2 < nx1
            || y1 > ny2
            || y2 < ny1;
      });
    };
  }
}
peopleGraph.init();

</script>